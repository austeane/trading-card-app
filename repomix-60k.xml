This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: client/src/**/*.ts, client/src/**/*.tsx, server/src/**/*.ts, shared/src/**/*.ts, sst.config.ts
- Files matching these patterns are excluded: *.md, repomix*.xml, shared/src/tournaments/*, client/src/components/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
client/
  src/
    Admin.tsx
    api.ts
    App.tsx
    draftStorage.ts
    env.d.ts
    main.tsx
    renderCard.ts
    router.tsx
    sst-env.d.ts
    vite-env.d.ts
server/
  src/
    dev.ts
    index.ts
    lambda.ts
shared/
  src/
    types/
      index.ts
    constants.ts
    index.ts
    templates.ts
    validation.ts
sst.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/src/draftStorage.ts">
 1: const STORAGE_KEY = 'trading-card-draft'
 2: export type SavedDraft = {
 3:   cardId: string
 4:   editToken: string
 5:   tournamentId: string
 6:   cardType: string
 7:   form: {
 8:     teamId: string
 9:     position: string
10:     jerseyNumber: string
11:     firstName: string
12:     lastName: string
13:     title: string
14:     caption: string
15:     photographer: string
16:     templateId: string
17:   }
18:   savedAt: string
19: }
20: export function saveDraft(draft: SavedDraft): void {
21:   try {
22:     localStorage.setItem(STORAGE_KEY, JSON.stringify(draft))
23:   } catch {
24:   }
25: }
26: export function loadDraft(): SavedDraft | null {
27:   try {
28:     const stored = localStorage.getItem(STORAGE_KEY)
29:     if (!stored) return null
30:     const draft = JSON.parse(stored) as SavedDraft
31:     if (!draft.cardId || !draft.editToken || !draft.tournamentId) {
32:       clearDraft()
33:       return null
34:     }
35:     return draft
36:   } catch {
37:     clearDraft()
38:     return null
39:   }
40: }
41: export function clearDraft(): void {
42:   try {
43:     localStorage.removeItem(STORAGE_KEY)
44:   } catch {
45:   }
46: }
</file>

<file path="client/src/env.d.ts">
1: interface ImportMetaEnv {
2:   readonly VITE_SENTRY_DSN?: string
3: }
</file>

<file path="client/src/vite-env.d.ts">
1: 
</file>

<file path="server/src/dev.ts">
1: import { serve } from '@hono/node-server'
2: import app from './index.js'
3: const port = Number(process.env.PORT ?? 3000)
4: console.log(`Hono dev server running on http://localhost:${port}`)
5: serve({
6:   fetch: app.fetch,
7:   port,
8: })
</file>

<file path="server/src/lambda.ts">
1: import { handle } from 'hono/aws-lambda'
2: import app from './index.js'
3: export const handler = handle(app)
</file>

<file path="shared/src/templates.ts">
 1: import type { CardType, TemplateDefinition, TournamentConfig } from "./types"
 2: export const DEFAULT_TEMPLATE_ID = "classic"
 3: export const resolveTemplateId = (
 4:   input: { templateId?: string | null; cardType?: CardType },
 5:   config?: TournamentConfig | null
 6: ) => {
 7:   const direct = typeof input.templateId === "string" ? input.templateId.trim() : ""
 8:   if (direct) return direct
 9:   const cardType = input.cardType
10:   const byType = cardType ? config?.defaultTemplates?.byCardType?.[cardType] : undefined
11:   if (byType) return byType
12:   const fallback = config?.defaultTemplates?.fallback
13:   if (fallback) return fallback
14:   return DEFAULT_TEMPLATE_ID
15: }
16: export const findTemplate = (
17:   config: TournamentConfig | null | undefined,
18:   templateId: string | null | undefined
19: ): TemplateDefinition | null => {
20:   if (!config?.templates || !templateId) return null
21:   return config.templates.find((template) => template.id === templateId) ?? null
22: }
</file>

<file path="shared/src/validation.ts">
 1: export const MAX_UPLOAD_BYTES = 15 * 1024 * 1024
 2: export const ALLOWED_UPLOAD_TYPES = [
 3:   'image/jpeg',
 4:   'image/png',
 5:   'image/webp',
 6: ] as const
 7: export const ALLOWED_RENDER_TYPES = ['image/png'] as const
 8: export const MAX_NAME_LENGTH = 24
 9: export const MAX_TITLE_LENGTH = 48
10: export const MAX_CAPTION_LENGTH = 120
11: export const MAX_PHOTOGRAPHER_LENGTH = 48
12: export const MAX_TEAM_LENGTH = 64
13: export const MAX_POSITION_LENGTH = 32
14: export const MAX_JERSEY_LENGTH = 2
15: export const JERSEY_PATTERN = /^\d{1,2}$/
</file>

<file path="client/src/api.ts">
 1: const API_BASE =
 2:   import.meta.env.DEV && import.meta.env.VITE_API_URL
 3:     ? import.meta.env.VITE_API_URL.replace(/\/$/, '')
 4:     : '/api'
 5: const MEDIA_BASE =
 6:   import.meta.env.DEV && import.meta.env.VITE_ROUTER_URL
 7:     ? import.meta.env.VITE_ROUTER_URL.replace(/\/$/, '')
 8:     : ''
 9: export const api = (path: string) => `${API_BASE}${path}`
10: export const media = (path: string) => `${MEDIA_BASE}${path}`
11: export const writeHeaders: HeadersInit = {}
12: export const publicPathForKey = (key: string) => {
13:   if (key.startsWith('renders/')) return `/r/${key.slice('renders/'.length)}`
14:   if (key.startsWith('config/')) return `/c/${key.slice('config/'.length)}`
15:   return `/${key}`
16: }
17: export const assetUrlForKey = (key: string) => media(publicPathForKey(key))
</file>

<file path="client/src/router.tsx">
 1: import { createRootRoute, createRoute, createRouter, Outlet } from '@tanstack/react-router'
 2: import App from './App'
 3: import Admin from './Admin'
 4: const rootRoute = createRootRoute({
 5:   component: () => <Outlet />,
 6: })
 7: const indexRoute = createRoute({
 8:   getParentRoute: () => rootRoute,
 9:   path: '/',
10:   component: App,
11: })
12: const adminRoute = createRoute({
13:   getParentRoute: () => rootRoute,
14:   path: '/admin',
15:   component: Admin,
16: })
17: const routeTree = rootRoute.addChildren([indexRoute, adminRoute])
18: export const router = createRouter({ routeTree })
</file>

<file path="client/src/sst-env.d.ts">
1: interface ImportMetaEnv {
2:   readonly VITE_API_URL: string
3:   readonly VITE_ROUTER_URL: string
4: }
5: interface ImportMeta {
6:   readonly env: ImportMetaEnv
7: }
</file>

<file path="shared/src/constants.ts">
 1: export const CARD_WIDTH = 825
 2: export const CARD_HEIGHT = 1125
 3: export const CARD_ASPECT = CARD_WIDTH / CARD_HEIGHT
 4: export const TRIM_INSET_PX = 37.5
 5: export const SAFE_INSET_PX = 75
 6: export const TRIM_BOX = { x: 37.5, y: 37.5, w: 750, h: 1050 }
 7: export const SAFE_BOX = { x: 75, y: 75, w: 675, h: 975 }
 8: export const GUIDE_PERCENTAGES = {
 9:   trim: { left: 4.545, top: 3.333, right: 4.545, bottom: 3.333 },
10:   safe: { left: 9.091, top: 6.667, right: 9.091, bottom: 6.667 },
11: }
</file>

<file path="client/src/main.tsx">
 1: import { StrictMode } from 'react'
 2: import { createRoot } from 'react-dom/client'
 3: import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
 4: import { RouterProvider } from '@tanstack/react-router'
 5: import * as Sentry from '@sentry/react'
 6: import { router } from './router'
 7: import './index.css'
 8: const sentryDsn =
 9:   import.meta.env.VITE_SENTRY_DSN ??
10:   'https://09af4582dc49164ae5df63813e981ebb@o4510562999664640.ingest.us.sentry.io/4510563001040896'
11: Sentry.init({
12:   dsn: sentryDsn,
13:   sendDefaultPii: false,
14:   integrations: [
15:     Sentry.browserTracingIntegration(),
16:     Sentry.replayIntegration({
17:       blockAllMedia: true,
18:       maskAllText: true,
19:     }),
20:   ],
21:   tracesSampleRate: 1.0,
22:   tracePropagationTargets: [
23:     'localhost',
24:     /^https:\/\/.*\.cloudfront\.net/,
25:     /^https:\/\/.*\.lambda-url\.us-east-1\.on\.aws/,
26:   ],
27:   replaysSessionSampleRate: import.meta.env.DEV ? 1.0 : 0.1,
28:   replaysOnErrorSampleRate: 1.0,
29:   enableLogs: true,
30:   environment: import.meta.env.MODE,
31: })
32: const queryClient = new QueryClient()
33: declare module '@tanstack/react-router' {
34:   interface Register {
35:     router: typeof router
36:   }
37: }
38: const rootElement = document.getElementById('root')
39: if (!rootElement) {
40:   throw new Error('Root element not found')
41: }
42: createRoot(rootElement).render(
43:   <StrictMode>
44:     <QueryClientProvider client={queryClient}>
45:       <RouterProvider router={router} />
46:     </QueryClientProvider>
47:   </StrictMode>
48: )
</file>

<file path="client/src/Admin.tsx">
  1: import { useEffect, useMemo, useState } from 'react'
  2: import JSZip from 'jszip'
  3: import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
  4: import { resolveTemplateId, type Card, type TournamentConfig, type TournamentListEntry } from 'shared'
  5: import { api, assetUrlForKey } from './api'
  6: import { renderCard, resolveTemplateSnapshot } from './renderCard'
  7: import TemplateEditor from './components/TemplateEditor'
  8: type LogosZipResult = {
  9:   uploaded: string[]
 10:   skipped: Array<{ filename: string; reason: string }>
 11:   missingLogos: string[]
 12: }
 13: type BundleImportResult = {
 14:   tournament: TournamentConfig
 15:   results: {
 16:     configSaved: boolean
 17:     assetsUploaded: string[]
 18:     assetsSkipped: string[]
 19:   }
 20: }
 21: type PresignResponse = {
 22:   uploadUrl: string
 23:   key: string
 24:   method: 'POST' | 'PUT'
 25:   headers?: Record<string, string>
 26:   fields?: Record<string, string>
 27: }
 28: const MAX_UPLOAD_RETRIES = 1
 29: const cardDisplayName = (card: Card) => {
 30:   if (card.cardType === 'rare') {
 31:     return card.title ?? 'Untitled rare card'
 32:   }
 33:   const fullName = [card.firstName, card.lastName].filter(Boolean).join(' ')
 34:   return fullName || 'Unnamed card'
 35: }
 36: const safeZipName = (value: string) =>
 37:   value
 38:     .normalize('NFKD')
 39:     .replace(/[/\\]/g, '-')
 40:     .replace(/\.\./g, '.')
 41:     .replace(/[^a-zA-Z0-9._ -]/g, '') // strip weird chars
 42:     .trim()
 43:     .replace(/\s+/g, '-')
 44:     .slice(0, 60) || 'card'
 45: const getUploadFilename = (key: string) => {
 46:   const lastSegment = key.split('/').pop()
 47:   return lastSegment && lastSegment.length > 0 ? lastSegment : 'upload'
 48: }
 49: const toUploadFile = (data: Blob, key: string) =>
 50:   data instanceof File
 51:     ? data
 52:     : new File([data], getUploadFilename(key), {
 53:         type: data.type || 'application/octet-stream',
 54:       })
 55: async function uploadToS3(presign: PresignResponse, data: Blob): Promise<void> {
 56:   const uploadOnce = async () => {
 57:     if (presign.method === 'POST') {
 58:       if (!presign.fields) {
 59:         throw new Error('Upload fields are missing')
 60:       }
 61:       const formData = new FormData()
 62:       for (const [key, value] of Object.entries(presign.fields)) {
 63:         formData.append(key, value)
 64:       }
 65:       formData.append('file', toUploadFile(data, presign.key))
 66:       const res = await fetch(presign.uploadUrl, { method: 'POST', body: formData })
 67:       if (!res.ok) throw new Error('Upload failed')
 68:       return
 69:     }
 70:     const res = await fetch(presign.uploadUrl, {
 71:       method: presign.method,
 72:       headers: presign.headers,
 73:       body: data,
 74:     })
 75:     if (!res.ok) throw new Error('Upload failed')
 76:   }
 77:   let lastError: unknown = null
 78:   for (let attempt = 0; attempt <= MAX_UPLOAD_RETRIES; attempt++) {
 79:     try {
 80:       await uploadOnce()
 81:       return
 82:     } catch (err) {
 83:       lastError = err
 84:     }
 85:   }
 86:   if (lastError instanceof Error) throw lastError
 87:   throw new Error('Upload failed')
 88: }
 89: export default function Admin() {
 90:   const queryClient = useQueryClient()
 91:   const [passwordInput, setPasswordInput] = useState('')
 92:   const [adminPassword, setAdminPassword] = useState(() => sessionStorage.getItem('adminPassword') ?? '')
 93:   const [activeTournamentId, setActiveTournamentId] = useState('')
 94:   const [configDraft, setConfigDraft] = useState('')
 95:   const [statusFilter, setStatusFilter] = useState('submitted')
 96:   const [logosZipFile, setLogosZipFile] = useState<File | null>(null)
 97:   const [logosZipResult, setLogosZipResult] = useState<LogosZipResult | null>(null)
 98:   const [bundleFile, setBundleFile] = useState<File | null>(null)
 99:   const [bundleResult, setBundleResult] = useState<BundleImportResult | null>(null)
100:   const [renderingCardId, setRenderingCardId] = useState<string | null>(null)
101:   useEffect(() => {
102:     if (adminPassword) {
103:       sessionStorage.setItem('adminPassword', adminPassword)
104:     }
105:   }, [adminPassword])
106:   const handleLogin = () => {
107:     if (passwordInput.trim()) {
108:       setAdminPassword(passwordInput.trim())
109:     }
110:   }
111:   const adminHeaders = useMemo(() => ({
112:     'Content-Type': 'application/json',
113:     'Authorization': `Bearer ${adminPassword}`,
114:   }), [adminPassword])
115:   const tournamentsQuery = useQuery({
116:     queryKey: ['admin-tournaments', adminPassword],
117:     queryFn: async () => {
118:       const res = await fetch(api('/admin/tournaments'), { headers: adminHeaders })
119:       if (!res.ok) throw new Error('Request failed')
120:       return res.json() as Promise<TournamentListEntry[]>
121:     },
122:     enabled: Boolean(adminPassword),
123:   })
124:   useEffect(() => {
125:     if (!activeTournamentId && tournamentsQuery.data?.length) {
126:       setActiveTournamentId(tournamentsQuery.data[0].id)
127:     }
128:   }, [activeTournamentId, tournamentsQuery.data])
129:   const configQuery = useQuery({
130:     queryKey: ['admin-config', activeTournamentId, adminPassword],
131:     queryFn: async () => {
132:       const res = await fetch(api(`/admin/tournaments/${activeTournamentId}`), { headers: adminHeaders })
133:       if (!res.ok) throw new Error('Request failed')
134:       return res.json() as Promise<TournamentConfig>
135:     },
136:     enabled: Boolean(activeTournamentId) && Boolean(adminPassword),
137:   })
138:   useEffect(() => {
139:     if (configQuery.data) {
140:       setConfigDraft(JSON.stringify(configQuery.data, null, 2))
141:     }
142:   }, [configQuery.data])
143:   const configParsed = useMemo(() => {
144:     try {
145:       return JSON.parse(configDraft) as TournamentConfig
146:     } catch {
147:       return null
148:     }
149:   }, [configDraft])
150:   const activeConfig = configParsed ?? configQuery.data ?? null
151:   const templateOptions = useMemo(() => {
152:     if (activeConfig?.templates && activeConfig.templates.length > 0) {
153:       return activeConfig.templates
154:     }
155:     return [
156:       { id: 'classic', label: 'Classic' },
157:       { id: 'noir', label: 'Noir' },
158:     ]
159:   }, [activeConfig])
160:   const templateLabelFor = (templateId: string) =>
161:     templateOptions.find((template) => template.id === templateId)?.label ?? templateId
162:   const uploadOverlay = async (templateId: string, file: File) => {
163:     if (!activeTournamentId) {
164:       throw new Error('Select a tournament first')
165:     }
166:     if (!adminPassword) {
167:       throw new Error('Admin password is required')
168:     }
169:     const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/assets/presign`), {
170:       method: 'POST',
171:       headers: adminHeaders,
172:       body: JSON.stringify({
173:         kind: 'templateOverlay',
174:         templateId,
175:         contentType: file.type,
176:       }),
177:     })
178:     if (!res.ok) {
179:       const error = await res.json().catch(() => ({}))
180:       throw new Error(error.error ?? 'Presign failed')
181:     }
182:     const presign = await res.json() as PresignResponse
183:     await uploadToS3(presign, file)
184:     return presign.key
185:   }
186:   const cardsQuery = useQuery({
187:     queryKey: ['admin-cards', statusFilter, activeTournamentId, adminPassword],
188:     queryFn: async () => {
189:       const params = new URLSearchParams({ status: statusFilter })
190:       if (activeTournamentId) params.set('tournamentId', activeTournamentId)
191:       const res = await fetch(api(`/admin/cards?${params}`), { headers: adminHeaders })
192:       if (!res.ok) throw new Error('Request failed')
193:       return res.json() as Promise<Card[]>
194:     },
195:     enabled: Boolean(adminPassword),
196:   })
197:   const saveConfigMutation = useMutation({
198:     mutationFn: async () => {
199:       const parsed = JSON.parse(configDraft) as TournamentConfig
200:       const res = await fetch(api(`/admin/tournaments/${activeTournamentId}`), {
201:         method: 'PUT',
202:         headers: adminHeaders,
203:         body: JSON.stringify(parsed),
204:       })
205:       if (!res.ok) {
206:         const error = await res.json().catch(() => ({}))
207:         throw new Error(error.error ?? 'Request failed')
208:       }
209:       return res.json() as Promise<TournamentConfig>
210:     },
211:     onSuccess: () => {
212:       queryClient.invalidateQueries({ queryKey: ['admin-config', activeTournamentId] })
213:     },
214:   })
215:   const publishMutation = useMutation({
216:     mutationFn: async () => {
217:       const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/publish`), {
218:         method: 'POST',
219:         headers: adminHeaders,
220:         body: JSON.stringify({}),
221:       })
222:       if (!res.ok) {
223:         const error = await res.json().catch(() => ({}))
224:         throw new Error(error.error ?? 'Request failed')
225:       }
226:       return res.json()
227:     },
228:     onSuccess: () => {
229:       queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
230:     },
231:   })
232:   const logosZipMutation = useMutation({
233:     mutationFn: async () => {
234:       if (!logosZipFile) throw new Error('Select a ZIP file')
235:       const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/logos-zip`), {
236:         method: 'POST',
237:         headers: { 'Authorization': `Bearer ${adminPassword}` },
238:         body: logosZipFile,
239:       })
240:       if (!res.ok) {
241:         const error = await res.json().catch(() => ({}))
242:         throw new Error(error.error ?? 'Upload failed')
243:       }
244:       return res.json() as Promise<LogosZipResult>
245:     },
246:     onSuccess: (data) => {
247:       setLogosZipResult(data)
248:       setLogosZipFile(null)
249:     },
250:   })
251:   const bundleImportMutation = useMutation({
252:     mutationFn: async () => {
253:       if (!bundleFile) throw new Error('Select a ZIP file')
254:       const res = await fetch(api('/admin/tournaments/import-bundle'), {
255:         method: 'POST',
256:         headers: { 'Authorization': `Bearer ${adminPassword}` },
257:         body: bundleFile,
258:       })
259:       if (!res.ok) {
260:         const error = await res.json().catch(() => ({}))
261:         throw new Error(error.error ?? 'Import failed')
262:       }
263:       return res.json() as Promise<BundleImportResult>
264:     },
265:     onSuccess: (data) => {
266:       setBundleResult(data)
267:       setBundleFile(null)
268:       setActiveTournamentId(data.tournament.id)
269:       queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
270:       queryClient.invalidateQueries({ queryKey: ['admin-config'] })
271:     },
272:   })
273:   const templateMutation = useMutation({
274:     mutationFn: async ({ id, templateId }: { id: string; templateId: string | null }) => {
275:       const res = await fetch(api(`/admin/cards/${id}`), {
276:         method: 'PATCH',
277:         headers: adminHeaders,
278:         body: JSON.stringify({ templateId }),
279:       })
280:       if (!res.ok) {
281:         const error = await res.json().catch(() => ({}))
282:         throw new Error(error.error ?? 'Request failed')
283:       }
284:       return res.json()
285:     },
286:     onMutate: async ({ id, templateId }) => {
287:       const queryKey = ['admin-cards', statusFilter, activeTournamentId, adminPassword] as const
288:       await queryClient.cancelQueries({ queryKey })
289:       const previous = queryClient.getQueryData<Card[]>(queryKey)
290:       queryClient.setQueryData<Card[]>(queryKey, (cards) =>
291:         (cards ?? []).map((c) =>
292:           c.id === id ? { ...c, templateId: templateId ?? undefined } : c
293:         )
294:       )
295:       return { previous, queryKey }
296:     },
297:     onError: (_err, _vars, context) => {
298:       if (context?.previous) {
299:         queryClient.setQueryData(context.queryKey, context.previous)
300:       }
301:     },
302:     onSettled: () => {
303:       queryClient.invalidateQueries({ queryKey: ['admin-cards', statusFilter, activeTournamentId] })
304:     },
305:   })
306:   const renderMutation = useMutation({
307:     mutationFn: async (card: Card) => {
308:       if (!activeConfig) {
309:         throw new Error('Tournament config is not available')
310:       }
311:       const photoRes = await fetch(api(`/admin/cards/${card.id}/photo-url`), {
312:         headers: { 'Authorization': `Bearer ${adminPassword}` },
313:       })
314:       if (!photoRes.ok) {
315:         const error = await photoRes.json().catch(() => ({}))
316:         throw new Error(error.error ?? 'Photo request failed')
317:       }
318:       const photoData = await photoRes.json() as { url: string }
319:       const { templateId, templateSnapshot } = resolveTemplateSnapshot({
320:         card,
321:         config: activeConfig,
322:       })
323:       const blob = await renderCard({
324:         card,
325:         config: activeConfig,
326:         imageUrl: photoData.url,
327:         resolveAssetUrl: assetUrlForKey,
328:         templateId,
329:       })
330:       const presignRes = await fetch(api(`/admin/cards/${card.id}/renders/presign`), {
331:         method: 'POST',
332:         headers: adminHeaders,
333:         body: JSON.stringify({
334:           contentType: blob.type || 'image/png',
335:           contentLength: blob.size,
336:         }),
337:       })
338:       if (!presignRes.ok) {
339:         const error = await presignRes.json().catch(() => ({}))
340:         throw new Error(error.error ?? 'Render presign failed')
341:       }
342:       const presign = await presignRes.json() as PresignResponse
343:       await uploadToS3(presign, blob)
344:       const renderMeta = {
345:         key: presign.key,
346:         templateId,
347:         renderedAt: new Date().toISOString(),
348:         templateSnapshot,
349:       }
350:       const commitRes = await fetch(api(`/admin/cards/${card.id}/renders/commit`), {
351:         method: 'POST',
352:         headers: adminHeaders,
353:         body: JSON.stringify({ renderKey: presign.key, renderMeta }),
354:       })
355:       if (!commitRes.ok) {
356:         const error = await commitRes.json().catch(() => ({}))
357:         throw new Error(error.error ?? 'Render commit failed')
358:       }
359:       return commitRes.json()
360:     },
361:     onMutate: (card) => {
362:       setRenderingCardId(card.id)
363:     },
364:     onSettled: () => {
365:       setRenderingCardId(null)
366:     },
367:     onSuccess: () => {
368:       queryClient.invalidateQueries({ queryKey: ['admin-cards', statusFilter, activeTournamentId] })
369:     },
370:   })
371:   const deleteMutation = useMutation({
372:     mutationFn: async (id: string) => {
373:       const res = await fetch(api(`/admin/cards/${id}`), {
374:         method: 'DELETE',
375:         headers: { 'Authorization': `Bearer ${adminPassword}` },
376:       })
377:       if (!res.ok) {
378:         const error = await res.json().catch(() => ({}))
379:         throw new Error(error.error ?? 'Delete failed')
380:       }
381:       return res.json()
382:     },
383:     onSuccess: () => {
384:       queryClient.invalidateQueries({ queryKey: ['admin-cards', statusFilter, activeTournamentId] })
385:     },
386:   })
387:   if (adminPassword && tournamentsQuery.isPending) {
388:     return (
389:       <div className="app-shell min-h-screen">
390:         <div className="mx-auto flex max-w-md flex-col items-center justify-center px-6 py-24">
391:           <div className="w-full rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur">
392:             <h1 className="font-display text-3xl text-white text-center">Admin Console</h1>
393:             <p className="mt-2 text-sm text-slate-400 text-center">
394:               Verifying credentials...
395:             </p>
396:           </div>
397:         </div>
398:       </div>
399:     )
400:   }
401:   if (!adminPassword) {
402:     return (
403:       <div className="app-shell min-h-screen">
404:         <div className="mx-auto flex max-w-md flex-col items-center justify-center px-6 py-24">
405:           <div className="w-full rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur">
406:             <h1 className="font-display text-3xl text-white text-center">Admin Console</h1>
407:             <p className="mt-2 text-sm text-slate-400 text-center">
408:               Enter the admin password to continue.
409:             </p>
410:             <form
411:               className="mt-6"
412:               onSubmit={(e) => {
413:                 e.preventDefault()
414:                 handleLogin()
415:               }}
416:             >
417:               <label htmlFor="admin-password" className="block text-xs text-slate-400 mb-2">
418:                 Password
419:               </label>
420:               <input
421:                 id="admin-password"
422:                 type="password"
423:                 value={passwordInput}
424:                 onChange={(e) => setPasswordInput(e.target.value)}
425:                 placeholder="Enter admin password"
426:                 className="w-full rounded-xl border border-white/20 bg-slate-950/50 px-4 py-3 text-sm text-white placeholder:text-slate-500"
427:                 autoFocus
428:               />
429:               <button
430:                 type="submit"
431:                 disabled={!passwordInput.trim()}
432:                 className="mt-4 w-full rounded-xl bg-white px-4 py-3 text-sm font-semibold text-slate-900 disabled:opacity-50"
433:               >
434:                 Sign In
435:               </button>
436:             </form>
437:           </div>
438:         </div>
439:       </div>
440:     )
441:   }
442:   if (tournamentsQuery.isError) {
443:     return (
444:       <div className="app-shell min-h-screen">
445:         <div className="mx-auto flex max-w-md flex-col items-center justify-center px-6 py-24">
446:           <div className="w-full rounded-3xl border border-rose-500/20 bg-rose-500/5 p-8 backdrop-blur">
447:             <h1 className="font-display text-3xl text-white text-center">Access Denied</h1>
448:             <p className="mt-2 text-sm text-rose-400 text-center">
449:               Invalid password. Please try again.
450:             </p>
451:             <form
452:               className="mt-6"
453:               onSubmit={(e) => {
454:                 e.preventDefault()
455:                 handleLogin()
456:               }}
457:             >
458:               <label htmlFor="admin-password" className="block text-xs text-slate-400 mb-2">
459:                 Password
460:               </label>
461:               <input
462:                 id="admin-password"
463:                 type="password"
464:                 value={passwordInput}
465:                 onChange={(e) => setPasswordInput(e.target.value)}
466:                 placeholder="Enter admin password"
467:                 className="w-full rounded-xl border border-white/20 bg-slate-950/50 px-4 py-3 text-sm text-white placeholder:text-slate-500"
468:                 autoFocus
469:               />
470:               <button
471:                 type="submit"
472:                 disabled={!passwordInput.trim()}
473:                 className="mt-4 w-full rounded-xl bg-white px-4 py-3 text-sm font-semibold text-slate-900 disabled:opacity-50"
474:               >
475:                 Sign In
476:               </button>
477:             </form>
478:             <button
479:               type="button"
480:               onClick={() => {
481:                 setAdminPassword('')
482:                 setPasswordInput('')
483:                 sessionStorage.removeItem('adminPassword')
484:                 queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
485:               }}
486:               className="mt-4 w-full rounded-xl border border-white/20 px-4 py-2 text-xs text-slate-400 hover:bg-white/5"
487:             >
488:               Clear and try again
489:             </button>
490:           </div>
491:         </div>
492:       </div>
493:     )
494:   }
495:   return (
496:     <div className="app-shell min-h-screen">
497:       <div className="mx-auto flex max-w-6xl flex-col gap-8 px-6 py-12">
498:         <header className="flex flex-wrap items-start justify-between gap-4">
499:           <div>
500:             <h1 className="font-display text-4xl text-white">Admin Console</h1>
501:             <p className="text-sm text-slate-400">
502:               Manage tournaments, upload assets, and review submissions.
503:             </p>
504:           </div>
505:           <div className="flex items-center gap-3">
506:             <span className="flex items-center gap-1.5 text-xs text-emerald-400">
507:               <span className="h-2 w-2 rounded-full bg-emerald-400" />
508:               Authenticated
509:             </span>
510:             <button
511:               type="button"
512:               onClick={() => {
513:                 setAdminPassword('')
514:                 setPasswordInput('')
515:                 sessionStorage.removeItem('adminPassword')
516:                 queryClient.invalidateQueries({ queryKey: ['admin-tournaments'] })
517:               }}
518:               className="rounded-full border border-white/20 px-3 py-1 text-xs text-slate-400 hover:bg-white/5"
519:             >
520:               Sign out
521:             </button>
522:           </div>
523:         </header>
524:         <div className="grid gap-8 lg:grid-cols-[1.1fr_0.9fr]">
525:           <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
526:             <div className="flex flex-wrap items-center justify-between gap-3">
527:               <h2 className="text-lg font-semibold text-white">Tournament Config</h2>
528:               <select
529:                 value={activeTournamentId}
530:                 onChange={(event) => setActiveTournamentId(event.target.value)}
531:                 className="rounded-full border border-white/20 bg-slate-950/50 px-3 py-1 text-xs text-white"
532:               >
533:                 {tournamentsQuery.data?.map((tournament) => (
534:                   <option key={tournament.id} value={tournament.id}>
535:                     {tournament.name}
536:                   </option>
537:                 ))}
538:               </select>
539:             </div>
540:             <textarea
541:               value={configDraft}
542:               onChange={(event) => setConfigDraft(event.target.value)}
543:               className="mt-4 h-72 w-full rounded-2xl border border-white/10 bg-slate-950/60 px-4 py-3 text-xs text-slate-200"
544:             />
545:             <div className="mt-4 flex flex-wrap items-center gap-3">
546:               <button
547:                 type="button"
548:                 onClick={() => saveConfigMutation.mutate()}
549:                 className="rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900"
550:               >
551:                 Save Draft
552:               </button>
553:               <button
554:                 type="button"
555:                 onClick={() => publishMutation.mutate()}
556:                 className="rounded-full border border-emerald-500/40 px-4 py-2 text-xs text-emerald-300"
557:               >
558:                 Publish
559:               </button>
560:               <button
561:                 type="button"
562:                 onClick={() => {
563:                   if (!configParsed) return
564:                   const blob = new Blob([JSON.stringify(configParsed, null, 2)], { type: 'application/json' })
565:                   const url = URL.createObjectURL(blob)
566:                   const link = document.createElement('a')
567:                   link.href = url
568:                   link.download = `${activeTournamentId}-config.json`
569:                   link.click()
570:                   URL.revokeObjectURL(url)
571:                 }}
572:                 className="rounded-full border border-white/20 px-4 py-2 text-xs text-white"
573:               >
574:                 Download JSON
575:               </button>
576:             </div>
577:           </section>
578:           <section className="space-y-6">
579:             <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
580:               <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">Upload Team Logos</h3>
581:               <p className="mt-2 text-xs text-slate-400">
582:                 Upload a ZIP file containing team logos. Each PNG file should be named with the team ID
583:                 (e.g., <code className="text-emerald-400">boston-kraken.png</code>).
584:               </p>
585:               <div className="mt-4 rounded-xl border border-dashed border-white/20 bg-slate-950/40 p-4">
586:                 <p className="text-xs text-slate-500 mb-2">Expected structure:</p>
587:                 <pre className="text-xs text-slate-400 font-mono">
588: {`logos.zip
589: ├── team-id-1.png
590: ├── team-id-2.png
591: └── ...`}
592:                 </pre>
593:               </div>
594:               <input
595:                 type="file"
596:                 accept=".zip"
597:                 className="mt-4 text-xs text-slate-300"
598:                 onChange={(event) => {
599:                   setLogosZipFile(event.target.files?.[0] ?? null)
600:                   setLogosZipResult(null)
601:                 }}
602:               />
603:               <button
604:                 type="button"
605:                 onClick={() => logosZipMutation.mutate()}
606:                 disabled={!logosZipFile || logosZipMutation.isPending}
607:                 className="mt-3 rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900 disabled:opacity-50"
608:               >
609:                 {logosZipMutation.isPending ? 'Uploading...' : 'Upload Logos ZIP'}
610:               </button>
611:               {logosZipMutation.isError && (
612:                 <p className="mt-2 text-xs text-rose-400">
613:                   {logosZipMutation.error instanceof Error ? logosZipMutation.error.message : 'Upload failed'}
614:                 </p>
615:               )}
616:               {logosZipResult && (
617:                 <div className="mt-4 space-y-2 text-xs">
618:                   <p className="text-emerald-400">
619:                     Uploaded: {logosZipResult.uploaded.length} logos
620:                   </p>
621:                   {logosZipResult.skipped.length > 0 && (
622:                     <div className="text-amber-400">
623:                       <p>Skipped {logosZipResult.skipped.length} files:</p>
624:                       <ul className="mt-1 ml-4 list-disc text-slate-400">
625:                         {logosZipResult.skipped.slice(0, 5).map((s, i) => (
626:                           <li key={i}>{s.filename}: {s.reason}</li>
627:                         ))}
628:                         {logosZipResult.skipped.length > 5 && (
629:                           <li>...and {logosZipResult.skipped.length - 5} more</li>
630:                         )}
631:                       </ul>
632:                     </div>
633:                   )}
634:                   {logosZipResult.missingLogos.length > 0 && (
635:                     <div className="text-rose-400">
636:                       <p>Teams still missing logos: {logosZipResult.missingLogos.length}</p>
637:                       <ul className="mt-1 ml-4 list-disc text-slate-400">
638:                         {logosZipResult.missingLogos.slice(0, 5).map((id) => (
639:                           <li key={id}>{id}</li>
640:                         ))}
641:                         {logosZipResult.missingLogos.length > 5 && (
642:                           <li>...and {logosZipResult.missingLogos.length - 5} more</li>
643:                         )}
644:                       </ul>
645:                     </div>
646:                   )}
647:                 </div>
648:               )}
649:             </div>
650:             <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
651:               <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">Tournament Bundle</h3>
652:               <p className="mt-2 text-xs text-slate-400">
653:                 Import or export a complete tournament as a ZIP bundle including config and all assets.
654:               </p>
655:               <div className="mt-4 rounded-xl border border-dashed border-white/20 bg-slate-950/40 p-4">
656:                 <p className="text-xs text-slate-500 mb-2">Bundle structure:</p>
657:                 <pre className="text-xs text-slate-400 font-mono">
658: {`tournament.zip
659: ├── config.json          (required)
660: ├── tournament-logo.png  (optional)
661: ├── org-logo.png         (optional)
662: └── teams/               (optional)
663:     ├── team-id-1.png
664:     └── ...`}
665:                 </pre>
666:               </div>
667:               <div className="mt-4 flex flex-wrap gap-3">
668:                 <button
669:                   type="button"
670:                   onClick={async () => {
671:                     const res = await fetch(api(`/admin/tournaments/${activeTournamentId}/bundle`), {
672:                       headers: { 'Authorization': `Bearer ${adminPassword}` },
673:                     })
674:                     if (!res.ok) return
675:                     const blob = await res.blob()
676:                     const url = URL.createObjectURL(blob)
677:                     const link = document.createElement('a')
678:                     link.href = url
679:                     link.download = `${activeTournamentId}-bundle.zip`
680:                     link.click()
681:                     URL.revokeObjectURL(url)
682:                   }}
683:                   className="rounded-full border border-emerald-500/40 px-4 py-2 text-xs text-emerald-300 hover:bg-emerald-500/10"
684:                 >
685:                   Export Bundle
686:                 </button>
687:               </div>
688:               <div className="mt-4 border-t border-white/10 pt-4">
689:                 <p className="text-xs text-slate-500 mb-2">Import a new tournament:</p>
690:                 <input
691:                   type="file"
692:                   accept=".zip"
693:                   className="text-xs text-slate-300"
694:                   onChange={(event) => {
695:                     setBundleFile(event.target.files?.[0] ?? null)
696:                     setBundleResult(null)
697:                   }}
698:                 />
699:                 <button
700:                   type="button"
701:                   onClick={() => bundleImportMutation.mutate()}
702:                   disabled={!bundleFile || bundleImportMutation.isPending}
703:                   className="mt-3 rounded-full bg-white px-4 py-2 text-xs font-semibold text-slate-900 disabled:opacity-50"
704:                 >
705:                   {bundleImportMutation.isPending ? 'Importing...' : 'Import Bundle'}
706:                 </button>
707:                 {bundleImportMutation.isError && (
708:                   <p className="mt-2 text-xs text-rose-400">
709:                     {bundleImportMutation.error instanceof Error ? bundleImportMutation.error.message : 'Import failed'}
710:                   </p>
711:                 )}
712:                 {bundleResult && (
713:                   <div className="mt-4 space-y-2 text-xs">
714:                     <p className="text-emerald-400">
715:                       Imported tournament: {bundleResult.tournament.name}
716:                     </p>
717:                     <p className="text-slate-400">
718:                       Assets uploaded: {bundleResult.results.assetsUploaded.length}
719:                     </p>
720:                     {bundleResult.results.assetsSkipped.length > 0 && (
721:                       <p className="text-amber-400">
722:                         Skipped: {bundleResult.results.assetsSkipped.join(', ')}
723:                       </p>
724:                     )}
725:                   </div>
726:                 )}
727:               </div>
728:             </div>
729:           </section>
730:         </div>
731:         {activeConfig ? (
732:           <TemplateEditor
733:             config={activeConfig}
734:             onChange={(next) => setConfigDraft(JSON.stringify(next, null, 2))}
735:             uploadOverlay={uploadOverlay}
736:           />
737:         ) : (
738:           <section className="rounded-3xl border border-white/10 bg-white/5 p-6 text-xs text-slate-400">
739:             Fix the tournament JSON to edit templates.
740:           </section>
741:         )}
742:         <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
743:           <div className="flex flex-wrap items-center justify-between gap-3">
744:             <h2 className="text-lg font-semibold text-white">Card Review</h2>
745:             <div className="flex items-center gap-3">
746:               <button
747:                 type="button"
748:                 onClick={async () => {
749:                   const cardsWithRenders = cardsQuery.data?.filter((c) => c.renderKey) ?? []
750:                   if (cardsWithRenders.length === 0) return
751:                   const zip = new JSZip()
752:                   for (const card of cardsWithRenders) {
753:                     const name = card.cardType === 'rare'
754:                       ? (card.title ?? 'rare-card')
755:                       : [card.firstName, card.lastName].filter(Boolean).join('-') || 'card'
756:                     const filename = `${safeZipName(name)}-${card.id.slice(0, 8)}.png`
757:                     const res = await fetch(api(`/admin/cards/${card.id}/download-url`), {
758:                       headers: { 'Authorization': `Bearer ${adminPassword}` },
759:                     })
760:                     if (res.ok) {
761:                       const { url: downloadUrl } = await res.json()
762:                       const imageRes = await fetch(downloadUrl)
763:                       if (imageRes.ok) {
764:                         const blob = await imageRes.blob()
765:                         zip.file(filename, blob)
766:                       }
767:                     }
768:                   }
769:                   const zipBlob = await zip.generateAsync({ type: 'blob' })
770:                   const url = URL.createObjectURL(zipBlob)
771:                   const link = document.createElement('a')
772:                   link.href = url
773:                   link.download = `cards-${statusFilter}-${new Date().toISOString().slice(0, 10)}.zip`
774:                   link.click()
775:                   URL.revokeObjectURL(url)
776:                 }}
777:                 disabled={!cardsQuery.data?.some((c) => c.renderKey)}
778:                 className="cursor-pointer rounded-full border border-white/20 px-3 py-1 text-xs text-white disabled:cursor-not-allowed disabled:opacity-50"
779:               >
780:                 Download All
781:               </button>
782:               <select
783:                 value={statusFilter}
784:                 onChange={(event) => setStatusFilter(event.target.value)}
785:                 className="rounded-full border border-white/20 bg-slate-950/50 px-3 py-1 text-xs text-white"
786:               >
787:                 <option value="draft">Draft</option>
788:                 <option value="submitted">Submitted</option>
789:                 <option value="rendered">Rendered</option>
790:               </select>
791:             </div>
792:           </div>
793:           {renderMutation.isError && (
794:             <p className="mt-2 text-xs text-rose-400">
795:               {renderMutation.error instanceof Error ? renderMutation.error.message : 'Render failed'}
796:             </p>
797:           )}
798:           <div className="mt-4 grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
799:             {cardsQuery.data?.map((card) => {
800:               const defaultTemplateId = resolveTemplateId(
801:                 { cardType: card.cardType },
802:                 activeConfig ?? undefined
803:               )
804:               const defaultTemplateLabel = templateLabelFor(defaultTemplateId)
805:               const hasUnknownTemplate =
806:                 Boolean(card.templateId) &&
807:                 !templateOptions.some((template) => template.id === card.templateId)
808:               const isRendering = renderingCardId === card.id
809:               return (
810:                 <div key={card.id} className="rounded-2xl border border-white/10 bg-slate-950/60 p-3 text-xs text-slate-300">
811:                   <div className="space-y-1">
812:                     <div className="text-sm text-white">{card.cardType}</div>
813:                     <div>{card.id}</div>
814:                     <div>{cardDisplayName(card)}</div>
815:                   </div>
816:                   <label className="mt-3 block text-[11px] uppercase tracking-wide text-slate-400">
817:                     Template Override
818:                     <select
819:                       value={card.templateId ?? ''}
820:                       onChange={(event) =>
821:                         templateMutation.mutate({
822:                           id: card.id,
823:                           templateId: event.target.value ? event.target.value : null,
824:                         })
825:                       }
826:                       className="mt-2 w-full rounded-lg border border-white/10 bg-slate-950/60 px-2 py-1 text-xs text-white"
827:                     >
828:                       <option value="">{`Default (${defaultTemplateLabel})`}</option>
829:                       {hasUnknownTemplate ? (
830:                         <option value={card.templateId ?? ''}>{`Custom (${card.templateId})`}</option>
831:                       ) : null}
832:                       {templateOptions.map((template) => (
833:                         <option key={template.id} value={template.id}>
834:                           {template.label}
835:                         </option>
836:                       ))}
837:                     </select>
838:                   </label>
839:                   {card.renderKey ? (
840:                     <img
841:                       src={assetUrlForKey(card.renderKey)}
842:                       alt="Rendered card"
843:                       className="mt-3 w-full rounded-xl"
844:                     />
845:                   ) : (
846:                     <div className="mt-3 flex aspect-[825/1125] items-center justify-center rounded-xl border border-dashed border-white/10 text-[11px] text-slate-500">
847:                       No render
848:                     </div>
849:                   )}
850:                   <div className="mt-3 flex flex-wrap gap-2">
851:                     {card.status !== 'draft' ? (
852:                       <button
853:                         type="button"
854:                         onClick={() => renderMutation.mutate(card)}
855:                         disabled={isRendering || renderMutation.isPending}
856:                         className="rounded-full border border-emerald-500/40 px-3 py-1 text-[11px] text-emerald-300 disabled:cursor-not-allowed disabled:opacity-50"
857:                       >
858:                         {isRendering ? 'Rendering...' : 'Render'}
859:                       </button>
860:                     ) : null}
861:                     {card.status === 'draft' ? (
862:                       <button
863:                         type="button"
864:                         onClick={() => deleteMutation.mutate(card.id)}
865:                         className="rounded-full border border-rose-500/40 px-3 py-1 text-[11px] text-rose-300"
866:                       >
867:                         Delete Draft
868:                       </button>
869:                     ) : null}
870:                   </div>
871:                 </div>
872:               )
873:             })}
874:           </div>
875:         </section>
876:       </div>
877:     </div>
878:   )
879: }
</file>

<file path="client/src/renderCard.ts">
  1: import {
  2:   CARD_HEIGHT,
  3:   CARD_WIDTH,
  4:   findTemplate,
  5:   resolveTemplateId,
  6:   type Card,
  7:   type CropRect,
  8:   type RenderMeta,
  9:   type TemplateDefinition,
 10:   type TemplateFlags,
 11:   type TemplateTheme,
 12:   type TournamentConfig,
 13: } from 'shared'
 14: const FONT_SANS = '"Sora", "Avenir Next", "Helvetica Neue", system-ui, sans-serif'
 15: const FONT_DISPLAY = '"Fraunces", "Iowan Old Style", serif'
 16: const BASE_THEME: TemplateTheme = {
 17:   gradientStart: 'rgba(15, 23, 42, 0)',
 18:   gradientEnd: 'rgba(15, 23, 42, 0.85)',
 19:   border: 'rgba(255, 255, 255, 0.1)',
 20:   accent: 'rgba(255, 255, 255, 0.5)',
 21:   label: '#ffffff',
 22:   nameColor: '#ffffff',
 23:   meta: '#ffffff',
 24:   watermark: 'rgba(255, 255, 255, 0.12)',
 25: }
 26: const FALLBACK_TEMPLATES: Record<string, TemplateDefinition> = {
 27:   classic: {
 28:     id: 'classic',
 29:     label: 'Classic',
 30:   },
 31:   noir: {
 32:     id: 'noir',
 33:     label: 'Noir',
 34:     theme: {
 35:       gradientStart: 'rgba(10, 10, 15, 0)',
 36:       gradientEnd: 'rgba(10, 10, 15, 0.92)',
 37:       border: 'rgba(255, 255, 255, 0.18)',
 38:       accent: 'rgba(255, 255, 255, 0.7)',
 39:       label: '#ffffff',
 40:       nameColor: '#ffffff',
 41:       meta: '#ffffff',
 42:       watermark: 'rgba(248, 250, 252, 0.2)',
 43:     },
 44:   },
 45: }
 46: const DEFAULT_TEMPLATE_FLAGS: TemplateFlags = {
 47:   showGradient: true,
 48:   showBorders: true,
 49:   showWatermarkJersey: true,
 50: }
 51: const overlayCache = new Map<string, Promise<HTMLImageElement | null>>()
 52: export type RenderCardInput = {
 53:   card: Card
 54:   config: TournamentConfig
 55:   imageUrl: string
 56:   resolveAssetUrl: (key: string) => string
 57:   templateId?: string
 58: }
 59: export const resolveTemplateSnapshot = (input: {
 60:   card: Card
 61:   config: TournamentConfig
 62:   templateId?: string
 63: }): { templateId: string; templateSnapshot: RenderMeta['templateSnapshot'] } => {
 64:   const effectiveTemplateId = resolveTemplateId(
 65:     { templateId: input.templateId ?? input.card.templateId, cardType: input.card.cardType },
 66:     input.config
 67:   )
 68:   const template =
 69:     findTemplate(input.config, effectiveTemplateId) ??
 70:     FALLBACK_TEMPLATES[effectiveTemplateId] ??
 71:     FALLBACK_TEMPLATES.classic
 72:   const theme = { ...BASE_THEME, ...(template.theme ?? {}) }
 73:   const flags = { ...DEFAULT_TEMPLATE_FLAGS, ...(template.flags ?? {}) }
 74:   const overlayPlacement = template.overlayPlacement ?? 'belowText'
 75:   return {
 76:     templateId: effectiveTemplateId,
 77:     templateSnapshot: {
 78:       overlayKey: template.overlayKey,
 79:       theme,
 80:       flags,
 81:       overlayPlacement,
 82:     },
 83:   }
 84: }
 85: function loadImage(url: string): Promise<HTMLImageElement> {
 86:   return new Promise((resolve, reject) => {
 87:     const img = new Image()
 88:     img.crossOrigin = 'anonymous'
 89:     img.onload = () => resolve(img)
 90:     img.onerror = () => reject(new Error('Failed to load image'))
 91:     img.src = url
 92:   })
 93: }
 94: async function loadImageSafe(url?: string | null) {
 95:   if (!url) return null
 96:   try {
 97:     return await loadImage(url)
 98:   } catch {
 99:     return null
100:   }
101: }
102: async function loadOverlay(
103:   overlayKey: string | undefined,
104:   resolveAssetUrl: (key: string) => string
105: ) {
106:   if (!overlayKey) return null
107:   const url = resolveAssetUrl(overlayKey)
108:   const cached = overlayCache.get(url)
109:   if (cached) return cached
110:   const promise = loadImage(url).catch(() => null)
111:   overlayCache.set(url, promise)
112:   return promise
113: }
114: function drawCroppedImage(
115:   ctx: CanvasRenderingContext2D,
116:   img: HTMLImageElement,
117:   crop: CropRect,
118:   destX: number,
119:   destY: number,
120:   destW: number,
121:   destH: number
122: ) {
123:   const { x, y, w, h, rotateDeg } = crop
124:   const srcX = x * img.naturalWidth
125:   const srcY = y * img.naturalHeight
126:   const srcW = w * img.naturalWidth
127:   const srcH = h * img.naturalHeight
128:   ctx.save()
129:   const centerX = destX + destW / 2
130:   const centerY = destY + destH / 2
131:   ctx.translate(centerX, centerY)
132:   ctx.rotate((rotateDeg * Math.PI) / 180)
133:   ctx.translate(-centerX, -centerY)
134:   ctx.drawImage(img, srcX, srcY, srcW, srcH, destX, destY, destW, destH)
135:   ctx.restore()
136: }
137: function drawOutlinedText(
138:   ctx: CanvasRenderingContext2D,
139:   text: string,
140:   x: number,
141:   y: number,
142:   strokeWidth = 3
143: ) {
144:   ctx.strokeStyle = 'black'
145:   ctx.lineWidth = strokeWidth
146:   ctx.lineJoin = 'round'
147:   ctx.strokeText(text, x, y)
148:   ctx.fillText(text, x, y)
149: }
150: function fillTextWithLetterSpacing(
151:   ctx: CanvasRenderingContext2D,
152:   text: string,
153:   x: number,
154:   y: number,
155:   spacingPx: number,
156:   strokeWidth = 2
157: ) {
158:   ctx.strokeStyle = 'black'
159:   ctx.lineWidth = strokeWidth
160:   ctx.lineJoin = 'round'
161:   let cursor = x
162:   for (const ch of text) {
163:     ctx.strokeText(ch, cursor, y)
164:     ctx.fillText(ch, cursor, y)
165:     cursor += ctx.measureText(ch).width + spacingPx
166:   }
167: }
168: function fitText(
169:   ctx: CanvasRenderingContext2D,
170:   text: string,
171:   maxWidth: number,
172:   initialSize: number,
173:   minSize: number,
174:   fontFamily: string,
175:   fontWeight = 'bold'
176: ) {
177:   let size = initialSize
178:   while (size > minSize) {
179:     ctx.font = `${fontWeight} ${size}px ${fontFamily}`
180:     if (ctx.measureText(text).width <= maxWidth) {
181:       return size
182:     }
183:     size -= 2
184:   }
185:   ctx.font = `${fontWeight} ${minSize}px ${fontFamily}`
186:   return minSize
187: }
188: function drawLogo(
189:   ctx: CanvasRenderingContext2D,
190:   img: HTMLImageElement,
191:   x: number,
192:   y: number,
193:   maxWidth: number,
194:   maxHeight: number
195: ) {
196:   const ratio = Math.min(maxWidth / img.naturalWidth, maxHeight / img.naturalHeight, 1)
197:   const width = img.naturalWidth * ratio
198:   const height = img.naturalHeight * ratio
199:   ctx.drawImage(img, x, y, width, height)
200: }
201: function getTeamInfo(card: Card, config: TournamentConfig) {
202:   if ('teamId' in card && card.teamId) {
203:     const team = config.teams.find((entry) => entry.id === card.teamId)
204:     if (team) return team
205:   }
206:   if ('teamName' in card && card.teamName) {
207:     return { id: 'custom', name: card.teamName, logoKey: '' }
208:   }
209:   return null
210: }
211: function getCardTypeLabel(card: Card, config: TournamentConfig) {
212:   const entry = config.cardTypes.find((type) => type.type === card.cardType)
213:   return entry?.label ?? card.cardType
214: }
215: function getCardTypeConfig(card: Card, config: TournamentConfig) {
216:   return config.cardTypes.find((type) => type.type === card.cardType)
217: }
218: export async function renderCropBlob(input: { imageUrl: string; crop: CropRect }): Promise<Blob> {
219:   const { imageUrl, crop } = input
220:   const img = await loadImage(imageUrl)
221:   const srcW = crop.w * img.naturalWidth
222:   const srcH = crop.h * img.naturalHeight
223:   const canvas = document.createElement('canvas')
224:   canvas.width = Math.max(1, Math.round(srcW))
225:   canvas.height = Math.max(1, Math.round(srcH))
226:   const ctx = canvas.getContext('2d')
227:   if (!ctx) {
228:     throw new Error('Could not get canvas context')
229:   }
230:   drawCroppedImage(ctx, img, crop, 0, 0, canvas.width, canvas.height)
231:   return new Promise((resolve, reject) => {
232:     canvas.toBlob(
233:       (blob) => {
234:         if (blob) resolve(blob)
235:         else reject(new Error('Failed to create blob'))
236:       },
237:       'image/png',
238:       1.0
239:     )
240:   })
241: }
242: export async function renderCard(input: RenderCardInput): Promise<Blob> {
243:   const { card, config, imageUrl, resolveAssetUrl, templateId } = input
244:   const { templateSnapshot } = resolveTemplateSnapshot({ card, config, templateId })
245:   const { theme, flags, overlayKey, overlayPlacement } = templateSnapshot
246:   if (document.fonts?.ready) {
247:     await document.fonts.ready
248:   }
249:   const canvas = document.createElement('canvas')
250:   canvas.width = CARD_WIDTH
251:   canvas.height = CARD_HEIGHT
252:   const ctx = canvas.getContext('2d')
253:   if (!ctx) {
254:     throw new Error('Could not get canvas context')
255:   }
256:   ctx.imageSmoothingEnabled = true
257:   ctx.imageSmoothingQuality = 'high'
258:   const img = await loadImage(imageUrl)
259:   const crop = card.photo?.crop ?? { x: 0, y: 0, w: 1, h: 1, rotateDeg: 0 }
260:   drawCroppedImage(ctx, img, crop, 0, 0, CARD_WIDTH, CARD_HEIGHT)
261:   if (flags.showGradient) {
262:     const overlayGradient = ctx.createLinearGradient(0, CARD_HEIGHT - 350, 0, CARD_HEIGHT)
263:     overlayGradient.addColorStop(0, theme.gradientStart)
264:     overlayGradient.addColorStop(1, theme.gradientEnd)
265:     ctx.fillStyle = overlayGradient
266:     ctx.fillRect(0, CARD_HEIGHT - 350, CARD_WIDTH, 350)
267:   }
268:   if (flags.showBorders) {
269:     ctx.strokeStyle = theme.border
270:     ctx.lineWidth = 2
271:     ctx.strokeRect(20, 20, CARD_WIDTH - 40, CARD_HEIGHT - 40)
272:     ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'
273:     ctx.lineWidth = 1
274:     ctx.strokeRect(30, 30, CARD_WIDTH - 60, CARD_HEIGHT - 60)
275:   }
276:   const overlayImg = await loadOverlay(overlayKey, resolveAssetUrl)
277:   if (overlayImg && overlayPlacement !== 'aboveText') {
278:     if (overlayImg.naturalWidth !== CARD_WIDTH || overlayImg.naturalHeight !== CARD_HEIGHT) {
279:       console.warn('Overlay is not 825x1125; scaling to fit.', overlayImg.naturalWidth, overlayImg.naturalHeight)
280:     }
281:     ctx.drawImage(overlayImg, 0, 0, CARD_WIDTH, CARD_HEIGHT)
282:   }
283:   const cardLabel = getCardTypeLabel(card, config).toUpperCase()
284:   ctx.font = `13px ${FONT_SANS}`
285:   ctx.fillStyle = theme.label
286:   ctx.textAlign = 'left'
287:   fillTextWithLetterSpacing(ctx, cardLabel, 50, 45, 2.5)
288:   const cardTypeConfig = getCardTypeConfig(card, config)
289:   const team = getTeamInfo(card, config)
290:   const logoKey =
291:     card.cardType === 'player' || card.cardType === 'team-staff'
292:       ? team?.logoKey
293:       : card.cardType === 'tournament-staff' || card.cardType === 'rare'
294:         ? config.branding.tournamentLogoKey
295:         : cardTypeConfig?.logoOverrideKey ?? config.branding.orgLogoKey
296:   const logoImg = await loadImageSafe(logoKey ? resolveAssetUrl(logoKey) : null)
297:   if (logoImg) {
298:     drawLogo(ctx, logoImg, CARD_WIDTH - 170, 40, 120, 80)
299:   }
300:   if (
301:     flags.showWatermarkJersey &&
302:     card.cardType !== 'rare' &&
303:     cardTypeConfig?.showJerseyNumber &&
304:     card.jerseyNumber
305:   ) {
306:     ctx.font = `bold 130px ${FONT_SANS}`
307:     ctx.fillStyle = theme.watermark
308:     ctx.textAlign = 'right'
309:     ctx.fillText(card.jerseyNumber, CARD_WIDTH - 50, 155)
310:   }
311:   if (card.cardType === 'rare') {
312:     const title = card.title ?? 'Rare Card'
313:     const caption = card.caption ?? ''
314:     ctx.strokeStyle = theme.accent
315:     ctx.lineWidth = 1
316:     ctx.beginPath()
317:     ctx.moveTo(120, CARD_HEIGHT / 2 - 40)
318:     ctx.lineTo(CARD_WIDTH - 120, CARD_HEIGHT / 2 - 40)
319:     ctx.stroke()
320:     ctx.beginPath()
321:     ctx.moveTo(120, CARD_HEIGHT / 2 + 40)
322:     ctx.lineTo(CARD_WIDTH - 120, CARD_HEIGHT / 2 + 40)
323:     ctx.stroke()
324:     const titleSize = fitText(ctx, title, CARD_WIDTH - 200, 52, 28, FONT_DISPLAY)
325:     ctx.font = `bold ${titleSize}px ${FONT_DISPLAY}`
326:     ctx.fillStyle = theme.nameColor
327:     ctx.textAlign = 'center'
328:     drawOutlinedText(ctx, title, CARD_WIDTH / 2, CARD_HEIGHT / 2 - 5, 4)
329:     if (caption) {
330:       ctx.font = `20px ${FONT_SANS}`
331:       ctx.fillStyle = theme.meta
332:       drawOutlinedText(ctx, caption, CARD_WIDTH / 2, CARD_HEIGHT / 2 + 30, 2)
333:     }
334:   } else {
335:     const fullName = [card.firstName, card.lastName].filter(Boolean).join(' ').trim()
336:     const nameText = fullName || 'Player Name'
337:     const nameFontSize = fitText(ctx, nameText, CARD_WIDTH - 100, 56, 34, FONT_DISPLAY)
338:     ctx.fillStyle = theme.nameColor
339:     ctx.textAlign = 'left'
340:     ctx.font = `bold ${nameFontSize}px ${FONT_DISPLAY}`
341:     drawOutlinedText(ctx, nameText, 50, CARD_HEIGHT - 180, 4)
342:     const positionTeam = [card.position, team?.name].filter(Boolean).join(' / ')
343:     ctx.font = `28px ${FONT_SANS}`
344:     ctx.fillStyle = theme.meta
345:     drawOutlinedText(ctx, positionTeam || 'Position / Team', 50, CARD_HEIGHT - 130, 2)
346:     if (cardTypeConfig?.showJerseyNumber && card.jerseyNumber) {
347:       ctx.font = `bold 36px ${FONT_SANS}`
348:       ctx.fillStyle = theme.meta
349:       drawOutlinedText(ctx, `#${card.jerseyNumber}`, 50, CARD_HEIGHT - 80, 3)
350:     }
351:   }
352:   if (card.photographer) {
353:     ctx.font = `18px ${FONT_SANS}`
354:     ctx.fillStyle = theme.label
355:     ctx.textAlign = 'right'
356:     drawOutlinedText(ctx, `Photo: ${card.photographer}`, CARD_WIDTH - 50, CARD_HEIGHT - 40, 2)
357:   }
358:   if (overlayImg && overlayPlacement === 'aboveText') {
359:     if (overlayImg.naturalWidth !== CARD_WIDTH || overlayImg.naturalHeight !== CARD_HEIGHT) {
360:       console.warn('Overlay is not 825x1125; scaling to fit.', overlayImg.naturalWidth, overlayImg.naturalHeight)
361:     }
362:     ctx.drawImage(overlayImg, 0, 0, CARD_WIDTH, CARD_HEIGHT)
363:   }
364:   return new Promise((resolve, reject) => {
365:     canvas.toBlob(
366:       (blob) => {
367:         if (blob) {
368:           resolve(blob)
369:         } else {
370:           reject(new Error('Failed to create blob'))
371:         }
372:       },
373:       'image/png',
374:       1.0
375:     )
376:   })
377: }
</file>

<file path="shared/src/types/index.ts">
  1: export type ApiResponse = {
  2:   message: string;
  3:   success: boolean;
  4: };
  5: export type CardType =
  6:   | "player"
  7:   | "team-staff"
  8:   | "media"
  9:   | "official"
 10:   | "tournament-staff"
 11:   | "rare";
 12: export type CardStatus = "draft" | "submitted" | "rendered";
 13: export type TemplateTheme = {
 14:   gradientStart: string;
 15:   gradientEnd: string;
 16:   border: string;
 17:   accent: string;
 18:   label: string;
 19:   nameColor: string;
 20:   meta: string;
 21:   watermark: string;
 22: };
 23: export type TemplateFlags = {
 24:   showGradient: boolean;
 25:   showBorders: boolean;
 26:   showWatermarkJersey: boolean;
 27: };
 28: export type TemplateDefinition = {
 29:   id: string;
 30:   label: string;
 31:   overlayKey?: string;
 32:   theme?: Partial<TemplateTheme>;
 33:   flags?: Partial<TemplateFlags>;
 34:   overlayPlacement?: "belowText" | "aboveText";
 35: };
 36: export type TemplateDefaults = {
 37:   fallback: string;
 38:   byCardType?: Partial<Record<CardType, string>>;
 39: };
 40: export type RenderMeta = {
 41:   key: string;
 42:   templateId: string;
 43:   renderedAt: string;
 44:   templateSnapshot: {
 45:     overlayKey?: string;
 46:     theme: TemplateTheme;
 47:     flags: TemplateFlags;
 48:     overlayPlacement: "belowText" | "aboveText";
 49:   };
 50: };
 51: export type CropRect = {
 52:   x: number;
 53:   y: number;
 54:   w: number;
 55:   h: number;
 56:   rotateDeg: 0 | 90 | 180 | 270;
 57: };
 58: export type CardPhoto = {
 59:   originalKey?: string;
 60:   width?: number;
 61:   height?: number;
 62:   crop?: CropRect;
 63:   cropKey?: string;
 64: };
 65: export type CardBase = {
 66:   id: string;
 67:   editToken?: string;
 68:   tournamentId: string;
 69:   cardType: CardType;
 70:   templateId?: string;
 71:   status: CardStatus;
 72:   photographer?: string;
 73:   photo?: CardPhoto;
 74:   renderKey?: string;
 75:   renderMeta?: RenderMeta;
 76:   createdAt: string;
 77:   updatedAt: string;
 78:   statusCreatedAt?: string;
 79: };
 80: export type StandardCard = CardBase & {
 81:   cardType: Exclude<CardType, "rare">;
 82:   firstName?: string;
 83:   lastName?: string;
 84:   teamId?: string;
 85:   teamName?: string;
 86:   position?: string;
 87:   jerseyNumber?: string;
 88: };
 89: export type RareCard = CardBase & {
 90:   cardType: "rare";
 91:   title?: string;
 92:   caption?: string;
 93: };
 94: export type Card = StandardCard | RareCard;
 95: export type TournamentListEntry = {
 96:   id: string;
 97:   name: string;
 98:   year: number;
 99:   published?: boolean;
100: };
101: export type TournamentConfig = {
102:   id: string;
103:   name: string;
104:   year: number;
105:   branding: {
106:     tournamentLogoKey: string;
107:     orgLogoKey?: string;
108:     primaryColor?: string;
109:   };
110:   teams: Array<{
111:     id: string;
112:     name: string;
113:     logoKey: string;
114:   }>;
115:   cardTypes: Array<{
116:     type: CardType;
117:     enabled: boolean;
118:     label: string;
119:     showTeamField: boolean;
120:     showJerseyNumber: boolean;
121:     positions?: string[];
122:     logoOverrideKey?: string;
123:   }>;
124:   templates?: TemplateDefinition[];
125:   defaultTemplates?: TemplateDefaults;
126:   createdAt: string;
127:   updatedAt: string;
128: };
129: export type CardDesign = Card;
</file>

<file path="shared/src/index.ts">
1: export * from "./types"
2: export * from "./constants"
3: export * from "./tournaments"
4: export * from "./validation"
5: export * from "./templates"
</file>

<file path="sst.config.ts">
  1: export default $config({
  2:   app(input) {
  3:     return {
  4:       name: "trading-card-app",
  5:       removal: input?.stage === "production" ? "retain" : "remove",
  6:       protect: ["production"].includes(input?.stage),
  7:       home: "aws",
  8:     };
  9:   },
 10:   async run() {
 11:     const adminPassword = new sst.Secret("AdminPassword");
 12:     const router = new sst.aws.Router("CardRouter");
 13:     const mediaBucket = new sst.aws.Bucket("Media", {
 14:       access: "cloudfront",
 15:       cors: {
 16:         allowHeaders: ["*"],
 17:         allowMethods: ["GET", "HEAD", "POST", "PUT"],
 18:         allowOrigins: ["*"],
 19:       },
 20:     });
 21:     new aws.s3.BucketLifecycleConfigurationV2("MediaUploadsLifecycle", {
 22:       bucket: mediaBucket.name,
 23:       rules: [
 24:         {
 25:           id: "expire-crop-uploads",
 26:           status: "Enabled",
 27:           filter: {
 28:             prefix: "uploads/crop/",
 29:           },
 30:           expiration: {
 31:             days: 14,
 32:           },
 33:         },
 34:         {
 35:           id: "expire-original-uploads",
 36:           status: "Enabled",
 37:           filter: {
 38:             prefix: "uploads/original/",
 39:           },
 40:           expiration: {
 41:             days: 730,
 42:           },
 43:         },
 44:         {
 45:           id: "expire-renders",
 46:           status: "Enabled",
 47:           filter: {
 48:             prefix: "renders/",
 49:           },
 50:           expiration: {
 51:             days: 365,
 52:           },
 53:         },
 54:       ],
 55:     });
 56:     const cardsTable = new sst.aws.Dynamo("Cards", {
 57:       fields: {
 58:         id: "string",
 59:         tournamentId: "string",
 60:         status: "string",
 61:         createdAt: "string",
 62:         statusCreatedAt: "string",
 63:       },
 64:       primaryIndex: { hashKey: "id" },
 65:       globalIndexes: {
 66:         byStatus: { hashKey: "status", rangeKey: "createdAt" },
 67:         byTournamentStatus: { hashKey: "tournamentId", rangeKey: "statusCreatedAt" },
 68:       },
 69:     });
 70:     const api = new sst.aws.Function("Api", {
 71:       handler: "server/src/lambda.handler",
 72:       runtime: "nodejs20.x",
 73:       url: {
 74:         cors: {
 75:           allowOrigins: ["*"],
 76:           allowMethods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
 77:           allowHeaders: ["Content-Type", "Authorization", "X-Edit-Token"],
 78:         },
 79:       },
 80:       link: [mediaBucket, cardsTable, adminPassword],
 81:     });
 82:     router.route("/api", api.url, {
 83:       rewrite: { regex: "^/api/(.*)$", to: "/$1" },
 84:     });
 85:     router.routeBucket("/r", mediaBucket, {
 86:       rewrite: { regex: "^/r/(.*)$", to: "/renders/$1" },
 87:     });
 88:     router.routeBucket("/c", mediaBucket, {
 89:       rewrite: { regex: "^/c/(.*)$", to: "/config/$1" },
 90:     });
 91:     const web = new sst.aws.StaticSite("Web", {
 92:       path: "client",
 93:       build: {
 94:         command: "pnpm build",
 95:         output: "dist",
 96:       },
 97:       environment: {
 98:         VITE_API_URL: api.url,
 99:         VITE_ROUTER_URL: router.url,
100:       },
101:       router: { instance: router },
102:     });
103:     return {
104:       web: web.url,
105:       api: api.url,
106:       router: router.url,
107:       media: mediaBucket.name,
108:       cards: cardsTable.name,
109:     };
110:   },
111: });
</file>

<file path="client/src/App.tsx">
   1: import { useCallback, useEffect, useMemo, useRef, useState, type ChangeEvent, type DragEvent, type MouseEvent } from 'react'
   2: import Cropper, { type Area, type MediaSize, type Point } from 'react-easy-crop'
   3: import { useMutation, useQuery } from '@tanstack/react-query'
   4: import {
   5:   ALLOWED_UPLOAD_TYPES as ALLOWED_UPLOAD_TYPES_LIST,
   6:   CARD_ASPECT,
   7:   JERSEY_PATTERN,
   8:   MAX_CAPTION_LENGTH,
   9:   MAX_JERSEY_LENGTH,
  10:   MAX_NAME_LENGTH,
  11:   MAX_PHOTOGRAPHER_LENGTH,
  12:   MAX_POSITION_LENGTH,
  13:   MAX_TEAM_LENGTH,
  14:   MAX_TITLE_LENGTH,
  15:   MAX_UPLOAD_BYTES,
  16:   resolveTemplateId,
  17:   type ApiResponse,
  18:   type Card,
  19:   type CardType,
  20:   type CropRect,
  21:   type TournamentConfig,
  22:   type TournamentListEntry,
  23:   USQC_2025_CONFIG,
  24:   USQC_2025_TOURNAMENT,
  25: } from 'shared'
  26: import { renderCard } from './renderCard'
  27: import { api, assetUrlForKey, media, writeHeaders } from './api'
  28: import { saveDraft, loadDraft, clearDraft, type SavedDraft } from './draftStorage'
  29: import CropGuides from './components/CropGuides'
  30: const ALLOWED_UPLOAD_TYPES: Set<string> = new Set(ALLOWED_UPLOAD_TYPES_LIST)
  31: const MAX_UPLOAD_RETRIES = 1
  32: const MAX_IMAGE_DIMENSION = 2600
  33: type FormState = {
  34:   tournamentId: string
  35:   cardType: CardType | ''
  36:   teamId: string
  37:   position: string
  38:   jerseyNumber: string
  39:   firstName: string
  40:   lastName: string
  41:   title: string
  42:   caption: string
  43:   photographer: string
  44:   templateId: string
  45: }
  46: type PhotoState = {
  47:   file: File
  48:   localUrl: string
  49:   width: number
  50:   height: number
  51: }
  52: type UploadedPhoto = {
  53:   key: string
  54:   publicUrl?: string
  55:   width: number
  56:   height: number
  57: }
  58: type SavePayload = {
  59:   tournamentId?: string
  60:   cardType?: CardType
  61:   templateId?: string
  62:   teamId?: string
  63:   teamName?: string
  64:   position?: string
  65:   jerseyNumber?: string
  66:   firstName?: string
  67:   lastName?: string
  68:   title?: string
  69:   caption?: string
  70:   photographer?: string
  71:   photo?: {
  72:     originalKey?: string
  73:     width?: number
  74:     height?: number
  75:     crop?: CropRect
  76:   }
  77: }
  78: type Rotation = CropRect['rotateDeg']
  79: type PresignResponse = {
  80:   uploadUrl: string
  81:   key: string
  82:   publicUrl?: string
  83:   method: 'POST' | 'PUT'
  84:   headers?: Record<string, string>
  85:   fields?: Record<string, string>
  86: }
  87: type UploadProgress = {
  88:   kind: 'original'
  89:   percent: number
  90: }
  91: const initialForm: FormState = {
  92:   tournamentId: '',
  93:   cardType: '',
  94:   teamId: '',
  95:   position: '',
  96:   jerseyNumber: '',
  97:   firstName: '',
  98:   lastName: '',
  99:   title: '',
 100:   caption: '',
 101:   photographer: '',
 102:   templateId: '',
 103: }
 104: const clamp = (value: number, min: number, max: number) =>
 105:   Math.min(Math.max(value, min), max)
 106: const toOptional = (value: string) => {
 107:   const trimmed = value.trim()
 108:   return trimmed.length > 0 ? trimmed : undefined
 109: }
 110: const buildDefaultCrop = (size: MediaSize, rotateDeg: Rotation): CropRect => {
 111:   const imageAspect = size.naturalWidth / size.naturalHeight
 112:   let w = 1
 113:   let h = 1
 114:   if (imageAspect > CARD_ASPECT) {
 115:     w = CARD_ASPECT / imageAspect
 116:   } else {
 117:     h = imageAspect / CARD_ASPECT
 118:   }
 119:   const x = clamp((1 - w) / 2, 0, 1)
 120:   const y = clamp((1 - h) / 2, 0, 1)
 121:   return {
 122:     x,
 123:     y,
 124:     w: clamp(w, 0.001, 1),
 125:     h: clamp(h, 0.001, 1),
 126:     rotateDeg,
 127:   }
 128: }
 129: async function fetchHello(): Promise<ApiResponse> {
 130:   const res = await fetch(api('/hello'))
 131:   if (!res.ok) {
 132:     throw new Error('API request failed')
 133:   }
 134:   return res.json()
 135: }
 136: async function fetchTournaments(): Promise<TournamentListEntry[]> {
 137:   const res = await fetch(api('/tournaments'))
 138:   if (!res.ok) {
 139:     throw new Error('Could not load tournaments')
 140:   }
 141:   return res.json()
 142: }
 143: async function fetchTournamentConfig(id: string): Promise<TournamentConfig> {
 144:   const res = await fetch(api(`/tournaments/${id}`))
 145:   if (!res.ok) {
 146:     throw new Error('Could not load tournament config')
 147:   }
 148:   return res.json()
 149: }
 150: const editHeadersFor = (editToken: string): HeadersInit => ({
 151:   'Content-Type': 'application/json',
 152:   ...writeHeaders,
 153:   'X-Edit-Token': editToken,
 154: })
 155: async function createCard(payload: SavePayload): Promise<Card> {
 156:   const res = await fetch(api('/cards'), {
 157:     method: 'POST',
 158:     headers: { 'Content-Type': 'application/json', ...writeHeaders },
 159:     body: JSON.stringify(payload),
 160:   })
 161:   if (!res.ok) {
 162:     throw new Error('Could not create card')
 163:   }
 164:   return res.json()
 165: }
 166: async function updateCard(id: string, payload: SavePayload, editToken: string): Promise<Card> {
 167:   const res = await fetch(api(`/cards/${id}`), {
 168:     method: 'PATCH',
 169:     headers: editHeadersFor(editToken),
 170:     body: JSON.stringify(payload),
 171:   })
 172:   if (!res.ok) {
 173:     throw new Error('Could not update card')
 174:   }
 175:   return res.json()
 176: }
 177: async function requestPresignFor(
 178:   cardId: string,
 179:   data: Blob,
 180:   kind: 'original',
 181:   editToken: string
 182: ): Promise<PresignResponse> {
 183:   const res = await fetch(api('/uploads/presign'), {
 184:     method: 'POST',
 185:     headers: editHeadersFor(editToken),
 186:     body: JSON.stringify({
 187:       cardId,
 188:       contentType: data.type,
 189:       contentLength: data.size,
 190:       kind,
 191:     }),
 192:   })
 193:   if (!res.ok) {
 194:     const error = await res.json().catch(() => ({}))
 195:     throw new Error(error.error ?? 'Could not get upload URL')
 196:   }
 197:   return res.json()
 198: }
 199: const getUploadFilename = (key: string) => {
 200:   const lastSegment = key.split('/').pop()
 201:   return lastSegment && lastSegment.length > 0 ? lastSegment : 'upload'
 202: }
 203: const toUploadFile = (data: Blob, key: string) =>
 204:   data instanceof File
 205:     ? data
 206:     : new File([data], getUploadFilename(key), {
 207:         type: data.type || 'application/octet-stream',
 208:       })
 209: async function uploadToS3(
 210:   presign: PresignResponse,
 211:   data: Blob,
 212:   onProgress?: (percent: number) => void
 213: ): Promise<void> {
 214:   const uploadOnce = () =>
 215:     new Promise<void>((resolve, reject) => {
 216:       const xhr = new XMLHttpRequest()
 217:       xhr.open(presign.method, presign.uploadUrl)
 218:       if (presign.method !== 'POST' && presign.headers) {
 219:         for (const [key, value] of Object.entries(presign.headers)) {
 220:           xhr.setRequestHeader(key, value)
 221:         }
 222:       }
 223:       if (xhr.upload && onProgress) {
 224:         xhr.upload.onprogress = (event) => {
 225:           const total = event.total || data.size
 226:           if (!total) return
 227:           const percent = Math.round((event.loaded / total) * 100)
 228:           onProgress(Math.min(100, Math.max(0, percent)))
 229:         }
 230:       }
 231:       xhr.onload = () => {
 232:         if (xhr.status >= 200 && xhr.status < 300) {
 233:           onProgress?.(100)
 234:           resolve()
 235:         } else {
 236:           reject(new Error('Upload failed'))
 237:         }
 238:       }
 239:       xhr.onerror = () => reject(new Error('Upload failed'))
 240:       xhr.onabort = () => reject(new Error('Upload aborted'))
 241:       if (presign.method === 'POST') {
 242:         if (!presign.fields) {
 243:           reject(new Error('Upload fields are missing'))
 244:           return
 245:         }
 246:         const formData = new FormData()
 247:         for (const [key, value] of Object.entries(presign.fields)) {
 248:           formData.append(key, value)
 249:         }
 250:         formData.append('file', toUploadFile(data, presign.key))
 251:         xhr.send(formData)
 252:         return
 253:       }
 254:       xhr.send(data)
 255:     })
 256:   let lastError: unknown = null
 257:   for (let attempt = 0; attempt <= MAX_UPLOAD_RETRIES; attempt++) {
 258:     try {
 259:       await uploadOnce()
 260:       return
 261:     } catch (err) {
 262:       lastError = err
 263:       if (attempt < MAX_UPLOAD_RETRIES) {
 264:         onProgress?.(0)
 265:       }
 266:     }
 267:   }
 268:   if (lastError instanceof Error) throw lastError
 269:   throw new Error('Upload failed')
 270: }
 271: async function submitCard(id: string, editToken: string): Promise<Card> {
 272:   const res = await fetch(api(`/cards/${id}/submit`), {
 273:     method: 'POST',
 274:     headers: editHeadersFor(editToken),
 275:     body: JSON.stringify({}),
 276:   })
 277:   if (!res.ok) {
 278:     throw new Error('Could not submit card')
 279:   }
 280:   return res.json()
 281: }
 282: function loadImageFromFile(file: File): Promise<HTMLImageElement> {
 283:   return new Promise((resolve, reject) => {
 284:     const url = URL.createObjectURL(file)
 285:     const img = new Image()
 286:     img.onload = () => {
 287:       URL.revokeObjectURL(url)
 288:       resolve(img)
 289:     }
 290:     img.onerror = () => {
 291:       URL.revokeObjectURL(url)
 292:       reject(new Error('Failed to load image'))
 293:     }
 294:     img.src = url
 295:   })
 296: }
 297: async function resizeImageIfNeeded(file: File): Promise<{ file: File; width: number; height: number }> {
 298:   const img = await loadImageFromFile(file)
 299:   const width = img.naturalWidth
 300:   const height = img.naturalHeight
 301:   const maxDim = Math.max(width, height)
 302:   if (maxDim <= MAX_IMAGE_DIMENSION) {
 303:     return { file, width, height }
 304:   }
 305:   const scale = MAX_IMAGE_DIMENSION / maxDim
 306:   const targetWidth = Math.max(1, Math.round(width * scale))
 307:   const targetHeight = Math.max(1, Math.round(height * scale))
 308:   const canvas = document.createElement('canvas')
 309:   canvas.width = targetWidth
 310:   canvas.height = targetHeight
 311:   const ctx = canvas.getContext('2d')
 312:   if (!ctx) {
 313:     return { file, width, height }
 314:   }
 315:   ctx.imageSmoothingEnabled = true
 316:   ctx.imageSmoothingQuality = 'high'
 317:   ctx.drawImage(img, 0, 0, targetWidth, targetHeight)
 318:   const blob = await new Promise<Blob>((resolve, reject) => {
 319:     canvas.toBlob(
 320:       (result) => {
 321:         if (result) resolve(result)
 322:         else reject(new Error('Failed to resize image'))
 323:       },
 324:       file.type || 'image/jpeg',
 325:       0.92
 326:     )
 327:   })
 328:   const resizedFile = new File([blob], file.name, { type: blob.type })
 329:   return { file: resizedFile, width: targetWidth, height: targetHeight }
 330: }
 331: function App() {
 332:   const [form, setForm] = useState<FormState>(initialForm)
 333:   const [selectedTournamentId, setSelectedTournamentId] = useState('')
 334:   const [photo, setPhoto] = useState<PhotoState | null>(null)
 335:   const fileInputRef = useRef<HTMLInputElement>(null)
 336:   const [uploadedPhoto, setUploadedPhoto] = useState<UploadedPhoto | null>(null)
 337:   const [mediaSize, setMediaSize] = useState<MediaSize | null>(null)
 338:   const [crop, setCrop] = useState<Point>({ x: 0, y: 0 })
 339:   const [zoom, setZoom] = useState(1)
 340:   const [rotation, setRotation] = useState<Rotation>(0)
 341:   const [normalizedCrop, setNormalizedCrop] = useState<CropRect | null>(null)
 342:   const [showGuides, setShowGuides] = useState(true)
 343:   const [cardId, setCardId] = useState<string | null>(null)
 344:   const [editToken, setEditToken] = useState<string | null>(null)
 345:   const [savedCard, setSavedCard] = useState<Card | null>(null)
 346:   const [uploadStatus, setUploadStatus] = useState<'idle' | 'uploading' | 'uploaded' | 'error'>('idle')
 347:   const [uploadProgress, setUploadProgress] = useState<UploadProgress | null>(null)
 348:   const [error, setError] = useState<string | null>(null)
 349:   const [photoError, setPhotoError] = useState<string | null>(null)
 350:   const [renderedCardUrl, setRenderedCardUrl] = useState<string | null>(null)
 351:   const [previewUrl, setPreviewUrl] = useState<string | null>(null)
 352:   const [previewError, setPreviewError] = useState<string | null>(null)
 353:   const [submitStatus, setSubmitStatus] = useState<'idle' | 'submitting' | 'done' | 'error'>('idle')
 354:   const [hasEdited, setHasEdited] = useState(false)
 355:   const [isDragging, setIsDragging] = useState(false)
 356:   const [pendingDraft, setPendingDraft] = useState<SavedDraft | null>(null)
 357:   const helloQuery = useQuery({
 358:     queryKey: ['hello'],
 359:     queryFn: fetchHello,
 360:     enabled: false,
 361:   })
 362:   const tournamentsQuery = useQuery({
 363:     queryKey: ['tournaments'],
 364:     queryFn: fetchTournaments,
 365:     initialData: [USQC_2025_TOURNAMENT],
 366:   })
 367:   useEffect(() => {
 368:     if (!selectedTournamentId && tournamentsQuery.data.length > 0) {
 369:       setSelectedTournamentId(tournamentsQuery.data[0].id)
 370:     }
 371:   }, [selectedTournamentId, tournamentsQuery.data])
 372:   useEffect(() => {
 373:     const draft = loadDraft()
 374:     if (draft) {
 375:       setPendingDraft(draft)
 376:     }
 377:   }, [])
 378:   const tournamentQuery = useQuery({
 379:     queryKey: ['tournament', form.tournamentId],
 380:     queryFn: () => fetchTournamentConfig(form.tournamentId),
 381:     enabled: Boolean(form.tournamentId),
 382:   })
 383:   const tournamentConfig =
 384:     tournamentQuery.data ??
 385:     (form.tournamentId === USQC_2025_CONFIG.id ? USQC_2025_CONFIG : null)
 386:   const cardTypeConfig = useMemo(
 387:     () => tournamentConfig?.cardTypes.find((entry) => entry.type === form.cardType),
 388:     [form.cardType, tournamentConfig]
 389:   )
 390:   const templateOptions = useMemo(() => {
 391:     if (tournamentConfig?.templates && tournamentConfig.templates.length > 0) {
 392:       return tournamentConfig.templates
 393:     }
 394:     return [
 395:       { id: 'classic', label: 'Classic' },
 396:       { id: 'noir', label: 'Noir' },
 397:     ]
 398:   }, [tournamentConfig])
 399:   const defaultTemplateId = useMemo(
 400:     () =>
 401:       resolveTemplateId(
 402:         {
 403:           cardType: form.cardType || undefined,
 404:         },
 405:         tournamentConfig ?? undefined
 406:       ),
 407:     [form.cardType, tournamentConfig]
 408:   )
 409:   const defaultTemplateLabel = useMemo(
 410:     () => templateOptions.find((template) => template.id === defaultTemplateId)?.label ?? defaultTemplateId,
 411:     [defaultTemplateId, templateOptions]
 412:   )
 413:   const hasUnknownTemplate = Boolean(form.templateId) && !templateOptions.some((template) => template.id === form.templateId)
 414:   const selectedTeam = useMemo(() => {
 415:     if (!tournamentConfig) return null
 416:     return tournamentConfig.teams.find((team) => team.id === form.teamId) ?? null
 417:   }, [form.teamId, tournamentConfig])
 418:   useEffect(() => {
 419:     if (!cardTypeConfig?.positions || cardTypeConfig.positions.length === 0) return
 420:     if (!form.position) return
 421:     if (!cardTypeConfig.positions.includes(form.position)) {
 422:       setForm((prev) => ({ ...prev, position: '' }))
 423:     }
 424:   }, [cardTypeConfig?.positions, form.position])
 425:   const buildPayload = (): SavePayload => ({
 426:     tournamentId: toOptional(form.tournamentId),
 427:     cardType: form.cardType || undefined,
 428:     templateId: toOptional(form.templateId),
 429:     teamId: toOptional(form.teamId),
 430:     teamName: selectedTeam?.name,
 431:     position: toOptional(form.position),
 432:     jerseyNumber: toOptional(form.jerseyNumber),
 433:     firstName: toOptional(form.firstName),
 434:     lastName: toOptional(form.lastName),
 435:     title: toOptional(form.title),
 436:     caption: toOptional(form.caption),
 437:     photographer: toOptional(form.photographer),
 438:   })
 439:   const buildUpdatePayload = (payload: SavePayload): SavePayload => {
 440:     const rest = { ...payload }
 441:     delete rest.tournamentId
 442:     delete rest.cardType
 443:     return rest
 444:   }
 445:   const buildPhotoPayload = (
 446:     source: UploadedPhoto | null,
 447:     cropValue: CropRect | null
 448:   ): SavePayload['photo'] | undefined => {
 449:     if (!source && !cropValue) return undefined
 450:     const payload: SavePayload['photo'] = {}
 451:     if (source) {
 452:       payload.originalKey = source.key
 453:       payload.width = source.width
 454:       payload.height = source.height
 455:     }
 456:     if (cropValue) {
 457:       payload.crop = cropValue
 458:     }
 459:     return payload
 460:   }
 461:   const ensureCard = async (payload: SavePayload) => {
 462:     if (cardId && editToken) return { id: cardId, editToken }
 463:     if (cardId && !editToken) {
 464:       throw new Error('Edit token is missing. Please refresh and try again.')
 465:     }
 466:     if (!payload.tournamentId || !payload.cardType) {
 467:       throw new Error('Select a tournament and card type before saving')
 468:     }
 469:     const card = await createCard(payload)
 470:     if (!card.editToken) {
 471:       throw new Error('Edit token is missing. Please refresh and try again.')
 472:     }
 473:     setCardId(card.id)
 474:     setEditToken(card.editToken)
 475:     setSavedCard(card)
 476:     saveDraft({
 477:       cardId: card.id,
 478:       editToken: card.editToken,
 479:       tournamentId: payload.tournamentId,
 480:       cardType: payload.cardType,
 481:       form: {
 482:         teamId: form.teamId,
 483:         position: form.position,
 484:         jerseyNumber: form.jerseyNumber,
 485:         firstName: form.firstName,
 486:         lastName: form.lastName,
 487:         title: form.title,
 488:         caption: form.caption,
 489:         photographer: form.photographer,
 490:         templateId: form.templateId,
 491:       },
 492:       savedAt: new Date().toISOString(),
 493:     })
 494:     return { id: card.id, editToken: card.editToken }
 495:   }
 496:   const uploadOriginalPhoto = async (currentCardId: string, currentEditToken: string) => {
 497:     if (!photo) {
 498:       throw new Error('Please upload a photo before submitting')
 499:     }
 500:     setUploadStatus('uploading')
 501:     setUploadProgress({ kind: 'original', percent: 0 })
 502:     try {
 503:       const presign = await requestPresignFor(currentCardId, photo.file, 'original', currentEditToken)
 504:       await uploadToS3(presign, photo.file, (percent) =>
 505:         setUploadProgress({ kind: 'original', percent })
 506:       )
 507:       const uploaded: UploadedPhoto = {
 508:         key: presign.key,
 509:         publicUrl: presign.publicUrl,
 510:         width: photo.width,
 511:         height: photo.height,
 512:       }
 513:       setUploadedPhoto(uploaded)
 514:       setUploadStatus('uploaded')
 515:       setUploadProgress(null)
 516:       return uploaded
 517:     } catch {
 518:       setUploadStatus('error')
 519:       setUploadProgress(null)
 520:       throw new Error('Photo upload failed. Please try again.')
 521:     }
 522:   }
 523:   const hasPhoto = Boolean(photo || uploadedPhoto)
 524:   const getValidationErrors = useCallback(() => {
 525:     const errors: Partial<Record<
 526:       | 'tournamentId'
 527:       | 'cardType'
 528:       | 'firstName'
 529:       | 'lastName'
 530:       | 'teamId'
 531:       | 'position'
 532:       | 'title'
 533:       | 'caption'
 534:       | 'photo'
 535:       | 'crop'
 536:       | 'jerseyNumber',
 537:       string
 538:     >> = {}
 539:     const firstName = form.firstName.trim()
 540:     const lastName = form.lastName.trim()
 541:     const position = form.position.trim()
 542:     const jerseyNumber = form.jerseyNumber.trim()
 543:     const title = form.title.trim()
 544:     const caption = form.caption.trim()
 545:     if (!form.tournamentId) {
 546:       errors.tournamentId = 'Tournament is required'
 547:     }
 548:     if (!form.cardType) {
 549:       errors.cardType = 'Card type is required'
 550:     }
 551:     if (form.cardType === 'rare') {
 552:       if (!title) {
 553:         errors.title = 'Title is required'
 554:       } else if (title.length > MAX_TITLE_LENGTH) {
 555:         errors.title = `Title must be ${MAX_TITLE_LENGTH} characters or fewer`
 556:       }
 557:       if (caption && caption.length > MAX_CAPTION_LENGTH) {
 558:         errors.caption = `Caption must be ${MAX_CAPTION_LENGTH} characters or fewer`
 559:       }
 560:     } else {
 561:       if (!firstName) {
 562:         errors.firstName = 'First name is required'
 563:       } else if (firstName.length > MAX_NAME_LENGTH) {
 564:         errors.firstName = `First name must be ${MAX_NAME_LENGTH} characters or fewer`
 565:       }
 566:       if (!lastName) {
 567:         errors.lastName = 'Last name is required'
 568:       } else if (lastName.length > MAX_NAME_LENGTH) {
 569:         errors.lastName = `Last name must be ${MAX_NAME_LENGTH} characters or fewer`
 570:       }
 571:       if (!position) {
 572:         errors.position = 'Position is required'
 573:       } else if (position.length > MAX_POSITION_LENGTH) {
 574:         errors.position = `Position must be ${MAX_POSITION_LENGTH} characters or fewer`
 575:       }
 576:       if (cardTypeConfig?.showTeamField && !form.teamId) {
 577:         errors.teamId = 'Team is required'
 578:       }
 579:     }
 580:     if (form.teamId && selectedTeam?.name && selectedTeam.name.length > MAX_TEAM_LENGTH) {
 581:       errors.teamId = `Team name must be ${MAX_TEAM_LENGTH} characters or fewer`
 582:     }
 583:     if (jerseyNumber && !JERSEY_PATTERN.test(jerseyNumber)) {
 584:       errors.jerseyNumber = 'Jersey number must be 1-2 digits'
 585:     }
 586:     if (!hasPhoto) errors.photo = 'Photo is required'
 587:     if (!normalizedCrop) errors.crop = 'Crop is required'
 588:     return errors
 589:   }, [
 590:     form.caption,
 591:     form.cardType,
 592:     form.firstName,
 593:     form.jerseyNumber,
 594:     form.lastName,
 595:     form.position,
 596:     form.teamId,
 597:     form.title,
 598:     form.tournamentId,
 599:     hasPhoto,
 600:     normalizedCrop,
 601:     cardTypeConfig,
 602:     selectedTeam,
 603:   ])
 604:   const saveMutation = useMutation({
 605:     mutationFn: async () => {
 606:       setError(null)
 607:       const payload = buildPayload()
 608:       const { id: currentCardId, editToken: currentEditToken } = await ensureCard(payload)
 609:       let photoPayload: SavePayload['photo'] = undefined
 610:       if (photo && !uploadedPhoto) {
 611:         const uploaded = await uploadOriginalPhoto(currentCardId, currentEditToken)
 612:         photoPayload = buildPhotoPayload(uploaded, normalizedCrop)
 613:       } else if (uploadedPhoto) {
 614:         photoPayload = buildPhotoPayload(uploadedPhoto, normalizedCrop)
 615:       } else if (normalizedCrop) {
 616:         photoPayload = buildPhotoPayload(null, normalizedCrop)
 617:       }
 618:       if (photoPayload) {
 619:         payload.photo = photoPayload
 620:       }
 621:       const updatedCard = await updateCard(currentCardId, buildUpdatePayload(payload), currentEditToken)
 622:       return updatedCard
 623:     },
 624:     onSuccess: (data) => {
 625:       setSavedCard(data)
 626:       if (data.editToken) setEditToken(data.editToken)
 627:       if (data.id && data.editToken && form.tournamentId && form.cardType) {
 628:         saveDraft({
 629:           cardId: data.id,
 630:           editToken: data.editToken,
 631:           tournamentId: form.tournamentId,
 632:           cardType: form.cardType,
 633:           form: {
 634:             teamId: form.teamId,
 635:             position: form.position,
 636:             jerseyNumber: form.jerseyNumber,
 637:             firstName: form.firstName,
 638:             lastName: form.lastName,
 639:             title: form.title,
 640:             caption: form.caption,
 641:             photographer: form.photographer,
 642:             templateId: form.templateId,
 643:           },
 644:           savedAt: new Date().toISOString(),
 645:         })
 646:       }
 647:     },
 648:     onError: (err) => {
 649:       setError(err instanceof Error ? err.message : 'Something went wrong')
 650:     },
 651:   })
 652:   const submitMutation = useMutation({
 653:     mutationFn: async () => {
 654:       setHasEdited(true)
 655:       const validationErrors = getValidationErrors()
 656:       if (photoError || Object.keys(validationErrors).length > 0) {
 657:         throw new Error('Please complete the required fields before submitting')
 658:       }
 659:       setError(null)
 660:       if (!tournamentConfig) {
 661:         throw new Error('Tournament config is not available')
 662:       }
 663:       const payload = buildPayload()
 664:       const { id: currentCardId, editToken: currentEditToken } = await ensureCard(payload)
 665:       const uploaded = uploadedPhoto ?? (photo ? await uploadOriginalPhoto(currentCardId, currentEditToken) : null)
 666:       if (!uploaded) {
 667:         throw new Error('Please upload a photo before submitting')
 668:       }
 669:       if (!normalizedCrop) {
 670:         throw new Error('Please set a crop before submitting')
 671:       }
 672:       const photoPayload = buildPhotoPayload(uploaded, normalizedCrop)
 673:       if (photoPayload) {
 674:         payload.photo = photoPayload
 675:       }
 676:       await updateCard(currentCardId, buildUpdatePayload(payload), currentEditToken)
 677:       setSubmitStatus('submitting')
 678:       const submitted = await submitCard(currentCardId, currentEditToken)
 679:       setSubmitStatus('done')
 680:       return submitted
 681:     },
 682:     onSuccess: (data) => {
 683:       setSavedCard(data)
 684:       if (data.editToken) setEditToken(data.editToken)
 685:       clearDraft()
 686:     },
 687:     onError: (err) => {
 688:       setSubmitStatus('error')
 689:       setError(err instanceof Error ? err.message : 'Submission failed')
 690:     },
 691:   })
 692:   const validationErrors = useMemo(() => getValidationErrors(), [getValidationErrors])
 693:   const canSubmit =
 694:     !submitMutation.isPending &&
 695:     !photoError &&
 696:     Object.keys(validationErrors).length === 0 &&
 697:     Boolean(tournamentConfig)
 698:   const inputClass = (hasError: boolean) =>
 699:     `mt-2 w-full rounded-xl border ${
 700:       hasError ? 'border-rose-500/60' : 'border-white/10'
 701:     } bg-slate-950/60 px-3 py-2 text-sm text-white`
 702:   const statusIndicator = useMemo(() => {
 703:     const errorMessage = error ?? (helloQuery.error instanceof Error ? helloQuery.error.message : null)
 704:     if (errorMessage) return { message: errorMessage, tone: 'error' as const }
 705:     if (submitStatus === 'submitting') return { message: 'Submitting card...', tone: 'warning' as const }
 706:     if (submitStatus === 'done') return { message: 'Card submitted!', tone: 'success' as const }
 707:     if (saveMutation.isPending) {
 708:       if (uploadStatus === 'uploading') return { message: 'Uploading photo...', tone: 'warning' as const }
 709:       return { message: 'Saving draft...', tone: 'warning' as const }
 710:     }
 711:     if (saveMutation.isSuccess) return { message: 'Draft saved', tone: 'success' as const }
 712:     if (hasEdited && Object.keys(validationErrors).length > 0) {
 713:       return { message: 'Complete required fields to submit.', tone: 'error' as const }
 714:     }
 715:     return { message: 'Draft not saved yet', tone: 'neutral' as const }
 716:   }, [
 717:     error,
 718:     helloQuery.error,
 719:     submitStatus,
 720:     saveMutation.isPending,
 721:     saveMutation.isSuccess,
 722:     uploadStatus,
 723:     hasEdited,
 724:     validationErrors,
 725:   ])
 726:   const statusToneClass = {
 727:     neutral: 'text-slate-400',
 728:     warning: 'text-amber-400',
 729:     success: 'text-emerald-400',
 730:     error: 'text-rose-300',
 731:   }[statusIndicator.tone]
 732:   const saveButtonLabel = saveMutation.isPending
 733:     ? uploadStatus === 'uploading'
 734:       ? 'Uploading...'
 735:       : 'Saving...'
 736:     : 'Save Draft'
 737:   const submitButtonLabel = submitMutation.isPending ? 'Submitting...' : 'Submit Card'
 738:   const isSubmitInProgress = submitStatus === 'submitting'
 739:   const handleFieldChange = (key: keyof FormState) =>
 740:     (event: ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
 741:       setHasEdited(true)
 742:       setError(null)
 743:       setForm((prev) => ({ ...prev, [key]: event.target.value }))
 744:     }
 745:   const handleCardTypeChange = (event: ChangeEvent<HTMLSelectElement>) => {
 746:     const value = event.target.value as CardType | ''
 747:     setHasEdited(true)
 748:     setError(null)
 749:     setForm((prev) => {
 750:       const next = { ...prev, cardType: value }
 751:       if (value === 'rare') {
 752:         return {
 753:           ...next,
 754:           teamId: '',
 755:           position: '',
 756:           jerseyNumber: '',
 757:           firstName: '',
 758:           lastName: '',
 759:         }
 760:       }
 761:       return {
 762:         ...next,
 763:         title: '',
 764:         caption: '',
 765:         teamId: value === 'player' || value === 'team-staff' ? next.teamId : '',
 766:         jerseyNumber: value === 'player' ? next.jerseyNumber : '',
 767:       }
 768:     })
 769:   }
 770:   const handleResumeDraft = useCallback(() => {
 771:     if (!pendingDraft) return
 772:     // Restore card identifiers
 773:     setCardId(pendingDraft.cardId)
 774:     setEditToken(pendingDraft.editToken)
 775:     // Restore form data
 776:     setForm({
 777:       tournamentId: pendingDraft.tournamentId,
 778:       cardType: pendingDraft.cardType as CardType | '',
 779:       ...pendingDraft.form,
 780:     })
 781:     setSelectedTournamentId(pendingDraft.tournamentId)
 782:     // Close the modal
 783:     setPendingDraft(null)
 784:   }, [pendingDraft])
 785:   const handleDismissDraft = useCallback(() => {
 786:     clearDraft()
 787:     setPendingDraft(null)
 788:   }, [])
 789:   const handleFileSelect = useCallback(async (file: File) => {
 790:     setHasEdited(true)
 791:     setError(null)
 792:     if (!ALLOWED_UPLOAD_TYPES.has(file.type)) {
 793:       setPhotoError('Unsupported file type. Use JPG, PNG, or WebP.')
 794:       return
 795:     }
 796:     if (file.size > MAX_UPLOAD_BYTES) {
 797:       setPhotoError('File is too large. Max size is 15MB.')
 798:       return
 799:     }
 800:     setPhotoError(null)
 801:     try {
 802:       const resized = await resizeImageIfNeeded(file)
 803:       const localUrl = URL.createObjectURL(resized.file)
 804:       setPhoto((prev) => {
 805:         if (prev) URL.revokeObjectURL(prev.localUrl)
 806:         return {
 807:           file: resized.file,
 808:           localUrl,
 809:           width: resized.width,
 810:           height: resized.height,
 811:         }
 812:       })
 813:       // Reset upload state when new photo is selected
 814:       setUploadedPhoto(null)
 815:       setUploadStatus('idle')
 816:       setUploadProgress(null)
 817:       setRenderedCardUrl(null)
 818:       setPreviewUrl(null)
 819:       setPreviewError(null)
 820:       setSubmitStatus('idle')
 821:       setMediaSize(null)
 822:       setCrop({ x: 0, y: 0 })
 823:       setZoom(1)
 824:       setRotation(0)
 825:       setNormalizedCrop(null)
 826:     } catch {
 827:       setError('Failed to load image')
 828:     }
 829:   }, [])
 830:   const handleFileChange = useCallback((event: ChangeEvent<HTMLInputElement>) => {
 831:     const file = event.target.files?.[0]
 832:     if (!file) return
 833:     void handleFileSelect(file)
 834:     event.target.value = ''
 835:   }, [handleFileSelect])
 836:   const handleUploadClick = useCallback((event: MouseEvent<HTMLElement>) => {
 837:     event.preventDefault()
 838:     const input = fileInputRef.current
 839:     if (!input) {
 840:       return
 841:     }
 842:     try {
 843:       if ('showPicker' in input && typeof (input as HTMLInputElement & { showPicker?: () => void }).showPicker === 'function') {
 844:         ;(input as HTMLInputElement & { showPicker: () => void }).showPicker()
 845:       } else {
 846:         input.click()
 847:       }
 848:     } catch (err) {
 849:       setError(err instanceof Error ? err.message : String(err))
 850:     }
 851:   }, [])
 852:   const handleDrop = useCallback((event: DragEvent<HTMLElement>) => {
 853:     event.preventDefault()
 854:     setIsDragging(false)
 855:     const file = event.dataTransfer.files?.[0]
 856:     if (file) {
 857:       void handleFileSelect(file)
 858:     }
 859:   }, [handleFileSelect])
 860:   const handleDragOver = useCallback((event: DragEvent<HTMLElement>) => {
 861:     event.preventDefault()
 862:     if (!isDragging) {
 863:       setIsDragging(true)
 864:     }
 865:   }, [isDragging])
 866:   const handleDragLeave = useCallback(() => {
 867:     setIsDragging(false)
 868:   }, [])
 869:   const handleCropComplete = useCallback((croppedAreaPercent: Area) => {
 870:     const clamp01 = (n: number) => Math.min(1, Math.max(0, n))
 871:     setNormalizedCrop({
 872:       x: clamp01(Number((croppedAreaPercent.x / 100).toFixed(4))),
 873:       y: clamp01(Number((croppedAreaPercent.y / 100).toFixed(4))),
 874:       w: clamp01(Number((croppedAreaPercent.width / 100).toFixed(4))),
 875:       h: clamp01(Number((croppedAreaPercent.height / 100).toFixed(4))),
 876:       rotateDeg: rotation,
 877:     })
 878:   }, [rotation])
 879:   const handleMediaLoaded = useCallback((size: MediaSize) => {
 880:     setMediaSize(size)
 881:     setNormalizedCrop((prev) => prev ?? buildDefaultCrop(size, rotation))
 882:   }, [rotation])
 883:   const handleZoom = (delta: number) => {
 884:     setZoom((prev) => clamp(Number((prev + delta).toFixed(2)), 1, 3))
 885:   }
 886:   const handleResetCrop = () => {
 887:     setCrop({ x: 0, y: 0 })
 888:     setZoom(1)
 889:     setRotation(0)
 890:     if (mediaSize) {
 891:       setNormalizedCrop(buildDefaultCrop(mediaSize, 0))
 892:     } else {
 893:       setNormalizedCrop(null)
 894:     }
 895:   }
 896:   const resetSession = useCallback(() => {
 897:     setCardId(null)
 898:     setEditToken(null)
 899:     setSavedCard(null)
 900:     setUploadedPhoto(null)
 901:     setUploadStatus('idle')
 902:     setUploadProgress(null)
 903:     setRenderedCardUrl(null)
 904:     setPreviewUrl(null)
 905:     setPreviewError(null)
 906:     setSubmitStatus('idle')
 907:     setHasEdited(false)
 908:     setError(null)
 909:     setPhotoError(null)
 910:     setNormalizedCrop(null)
 911:     setMediaSize(null)
 912:     setCrop({ x: 0, y: 0 })
 913:     setZoom(1)
 914:     setRotation(0)
 915:     setPhoto((prev) => {
 916:       if (prev) URL.revokeObjectURL(prev.localUrl)
 917:       return null
 918:     })
 919:   }, [])
 920:   const handleTournamentContinue = () => {
 921:     if (!selectedTournamentId) return
 922:     resetSession()
 923:     setForm((prev) => ({
 924:       ...initialForm,
 925:       tournamentId: selectedTournamentId,
 926:       templateId: prev.templateId,
 927:     }))
 928:   }
 929:   const handleTournamentReset = () => {
 930:     resetSession()
 931:     setForm(initialForm)
 932:   }
 933:   const handleSaveDraft = () => {
 934:     setHasEdited(true)
 935:     saveMutation.mutate()
 936:   }
 937:   const displayName = useMemo(() => {
 938:     if (form.cardType === 'rare') {
 939:       const title = form.title.trim()
 940:       return title.length > 0 ? title : 'Rare Card'
 941:     }
 942:     const first = form.firstName.trim()
 943:     const last = form.lastName.trim()
 944:     const full = [first, last].filter(Boolean).join(' ')
 945:     return full.length > 0 ? full : 'Player Name'
 946:   }, [form.cardType, form.firstName, form.lastName, form.title])
 947:   const uploadedCropperUrl = uploadedPhoto?.publicUrl ? media(uploadedPhoto.publicUrl) : null
 948:   const cropperImageUrl = photo?.localUrl ?? uploadedCropperUrl
 949:   const buildCardForRender = useCallback(
 950:     (timestamp: string): Card | null => {
 951:       if (!form.cardType || !form.tournamentId) return null
 952:       return {
 953:         id: cardId ?? 'preview',
 954:         tournamentId: form.tournamentId,
 955:         cardType: form.cardType as CardType,
 956:         status: savedCard?.status ?? 'draft',
 957:         createdAt: savedCard?.createdAt ?? timestamp,
 958:         updatedAt: timestamp,
 959:         templateId: toOptional(form.templateId),
 960:         photographer: toOptional(form.photographer),
 961:         photo: normalizedCrop ? { crop: normalizedCrop } : undefined,
 962:         firstName: toOptional(form.firstName),
 963:         lastName: toOptional(form.lastName),
 964:         position: toOptional(form.position),
 965:         teamId: toOptional(form.teamId),
 966:         teamName: selectedTeam?.name,
 967:         jerseyNumber: toOptional(form.jerseyNumber),
 968:         title: toOptional(form.title),
 969:         caption: toOptional(form.caption),
 970:       }
 971:     },
 972:     [
 973:       cardId,
 974:       form.caption,
 975:       form.cardType,
 976:       form.firstName,
 977:       form.jerseyNumber,
 978:       form.lastName,
 979:       form.photographer,
 980:       form.position,
 981:       form.teamId,
 982:       form.templateId,
 983:       form.title,
 984:       form.tournamentId,
 985:       normalizedCrop,
 986:       savedCard?.createdAt,
 987:       savedCard?.status,
 988:       selectedTeam,
 989:     ]
 990:   )
 991:   useEffect(() => {
 992:     if (!tournamentConfig || !cropperImageUrl || !normalizedCrop || !form.cardType) {
 993:       setPreviewUrl((prev) => {
 994:         if (prev) URL.revokeObjectURL(prev)
 995:         return null
 996:       })
 997:       setPreviewError(null)
 998:       return
 999:     }
1000:     let cancelled = false
1001:     const timeout = setTimeout(async () => {
1002:       try {
1003:         const timestamp = new Date().toISOString()
1004:         const card = buildCardForRender(timestamp)
1005:         if (!card) return
1006:         const blob = await renderCard({
1007:           card,
1008:           config: tournamentConfig,
1009:           imageUrl: cropperImageUrl,
1010:           resolveAssetUrl: assetUrlForKey,
1011:           templateId: toOptional(form.templateId),
1012:         })
1013:         if (cancelled) return
1014:         const url = URL.createObjectURL(blob)
1015:         setPreviewUrl((prev) => {
1016:           if (prev) URL.revokeObjectURL(prev)
1017:           return url
1018:         })
1019:         setPreviewError(null)
1020:       } catch {
1021:         if (!cancelled) {
1022:           setPreviewError('Preview failed to render')
1023:         }
1024:       }
1025:     }, 500)
1026:     return () => {
1027:       cancelled = true
1028:       clearTimeout(timeout)
1029:     }
1030:   }, [buildCardForRender, cropperImageUrl, form.cardType, form.templateId, normalizedCrop, tournamentConfig])
1031:   return (
1032:     <div className="app-shell min-h-screen">
1033:       {}
1034:       {pendingDraft && (
1035:         <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm">
1036:           <div className="mx-4 w-full max-w-md rounded-2xl border border-white/10 bg-slate-900 p-6 shadow-xl">
1037:             <h2 className="text-lg font-semibold text-white">Resume your draft?</h2>
1038:             <p className="mt-2 text-sm text-slate-300">
1039:               You have an unsaved draft from {new Date(pendingDraft.savedAt).toLocaleString()}.
1040:               Would you like to continue where you left off?
1041:             </p>
1042:             <p className="mt-2 text-xs text-slate-400">
1043:               Note: You&apos;ll need to re-upload your photo.
1044:             </p>
1045:             <div className="mt-6 flex gap-3">
1046:               <button
1047:                 onClick={handleResumeDraft}
1048:                 className="flex-1 rounded-xl bg-indigo-600 px-4 py-2.5 text-sm font-medium text-white hover:bg-indigo-500"
1049:               >
1050:                 Resume Draft
1051:               </button>
1052:               <button
1053:                 onClick={handleDismissDraft}
1054:                 className="flex-1 rounded-xl border border-white/10 bg-white/5 px-4 py-2.5 text-sm font-medium text-white hover:bg-white/10"
1055:               >
1056:                 Start Fresh
1057:               </button>
1058:             </div>
1059:           </div>
1060:         </div>
1061:       )}
1062:       <div className="mx-auto flex max-w-6xl flex-col gap-10 px-6 py-12">
1063:         <header className="flex flex-col gap-4">
1064:           <p className="text-xs uppercase tracking-[0.3em] text-slate-400">
1065:             Trading Card Studio
1066:           </p>
1067:           <div className="space-y-2">
1068:             <h1 className="font-display text-4xl text-white md:text-5xl">
1069:               Build and submit your trading card
1070:             </h1>
1071:             <p className="max-w-2xl text-base text-slate-300">
1072:               Upload a photo, drag to frame the shot, and submit when it looks right.
1073:               We save a draft automatically as part of submission.
1074:             </p>
1075:           </div>
1076:         </header>
1077:         {!form.tournamentId ? (
1078:           <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
1079:             <div className="flex flex-wrap items-center justify-between gap-4">
1080:               <div>
1081:                 <h2 className="text-lg font-semibold text-white">Select a tournament</h2>
1082:                 <p className="text-sm text-slate-400">
1083:                   Choose a tournament to load teams, positions, and branding.
1084:                 </p>
1085:               </div>
1086:               <span className="text-xs text-slate-400">
1087:                 {tournamentsQuery.isFetching ? 'Loading…' : `${tournamentsQuery.data.length} available`}
1088:               </span>
1089:             </div>
1090:             <div className="mt-6 flex flex-col gap-4 sm:flex-row sm:items-end">
1091:               <label className="flex-1 text-xs uppercase tracking-wide text-slate-400">
1092:                 Tournament
1093:                 <select
1094:                   value={selectedTournamentId}
1095:                   onChange={(event) => setSelectedTournamentId(event.target.value)}
1096:                   className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
1097:                 >
1098:                   <option value="">Select tournament</option>
1099:                   {tournamentsQuery.data.map((tournament) => (
1100:                     <option key={tournament.id} value={tournament.id}>
1101:                       {tournament.name} {tournament.year}
1102:                     </option>
1103:                   ))}
1104:                 </select>
1105:               </label>
1106:               <button
1107:                 type="button"
1108:                 onClick={handleTournamentContinue}
1109:                 disabled={!selectedTournamentId}
1110:                 className="rounded-full bg-emerald-500 px-6 py-2 text-xs font-semibold text-white transition hover:bg-emerald-400 disabled:cursor-not-allowed disabled:opacity-60"
1111:               >
1112:                 Continue →
1113:               </button>
1114:             </div>
1115:             <p className="mt-3 text-xs text-slate-500">
1116:               Admins can publish new tournaments from the admin panel.
1117:             </p>
1118:           </section>
1119:         ) : (
1120:           <div className="grid gap-10 lg:grid-cols-[1.05fr_0.95fr]">
1121:             <section className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
1122:               <div className="flex flex-wrap items-center justify-between gap-4">
1123:                 <div>
1124:                   <h2 className="text-lg font-semibold text-white">Card Details</h2>
1125:                   <p className="text-sm text-slate-400">
1126:                     Draft ID: {cardId ?? 'Auto-created on submit'}
1127:                   </p>
1128:                   <p className="text-xs text-slate-500">Fields marked * are required.</p>
1129:                 </div>
1130:                 <div className="flex items-center gap-3 text-xs text-slate-400">
1131:                   <button
1132:                     type="button"
1133:                     onClick={() => helloQuery.refetch()}
1134:                     className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
1135:                   >
1136:                     Ping API
1137:                   </button>
1138:                   <span>{helloQuery.data ? 'Connected' : 'Idle'}</span>
1139:                 </div>
1140:               </div>
1141:               <div className="mt-4 flex flex-wrap items-center justify-between gap-3 rounded-2xl border border-white/10 bg-slate-950/40 px-4 py-3 text-xs text-slate-300">
1142:                 <div>
1143:                   <span className="uppercase tracking-[0.2em] text-slate-500">Tournament</span>
1144:                   <div className="mt-1 text-sm text-white">
1145:                     {tournamentConfig?.name ?? form.tournamentId}
1146:                   </div>
1147:                 </div>
1148:                 <button
1149:                   type="button"
1150:                   onClick={handleTournamentReset}
1151:                   className="rounded-full border border-white/20 px-3 py-1 text-[11px] text-white transition hover:border-white/40"
1152:                 >
1153:                   Change
1154:                 </button>
1155:               </div>
1156:               {!tournamentConfig ? (
1157:                 <p className="mt-2 text-xs text-rose-300">
1158:                   Tournament config failed to load. Refresh or reselect the tournament.
1159:                 </p>
1160:               ) : null}
1161:               <form
1162:                 className="mt-6 grid gap-4 sm:grid-cols-2"
1163:                 onSubmit={(event) => {
1164:                   event.preventDefault()
1165:                   setHasEdited(true)
1166:                   if (canSubmit) submitMutation.mutate()
1167:                 }}
1168:               >
1169:                 <label className="text-xs uppercase tracking-wide text-slate-400">
1170:                   Card Type <span className="text-rose-400">*</span>
1171:                   <select
1172:                     value={form.cardType}
1173:                     onChange={handleCardTypeChange}
1174:                     disabled={!tournamentConfig}
1175:                     className={inputClass(hasEdited && Boolean(validationErrors.cardType))}
1176:                   >
1177:                     <option value="">Select type</option>
1178:                     {tournamentConfig?.cardTypes
1179:                       .filter((entry) => entry.enabled)
1180:                       .map((entry) => (
1181:                         <option key={entry.type} value={entry.type}>
1182:                           {entry.label}
1183:                         </option>
1184:                       ))}
1185:                   </select>
1186:                   {hasEdited && validationErrors.cardType ? (
1187:                     <span className="mt-1 block text-[11px] text-rose-300">
1188:                       {validationErrors.cardType}
1189:                     </span>
1190:                   ) : null}
1191:                 </label>
1192:                 <label className="text-xs uppercase tracking-wide text-slate-400">
1193:                   Card Style
1194:                   <select
1195:                     value={form.templateId}
1196:                     onChange={handleFieldChange('templateId')}
1197:                     className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
1198:                   >
1199:                     <option value="">{`Default (${defaultTemplateLabel})`}</option>
1200:                     {hasUnknownTemplate ? (
1201:                       <option value={form.templateId}>{`Custom (${form.templateId})`}</option>
1202:                     ) : null}
1203:                     {templateOptions.map((template) => (
1204:                       <option key={template.id} value={template.id}>
1205:                         {template.label}
1206:                       </option>
1207:                     ))}
1208:                   </select>
1209:                 </label>
1210:                 {form.cardType === 'rare' ? (
1211:                   <>
1212:                     <label className="text-xs uppercase tracking-wide text-slate-400 sm:col-span-2">
1213:                       Title <span className="text-rose-400">*</span>
1214:                       <input
1215:                         value={form.title}
1216:                         onChange={handleFieldChange('title')}
1217:                         maxLength={MAX_TITLE_LENGTH}
1218:                         className={inputClass(hasEdited && Boolean(validationErrors.title))}
1219:                         placeholder="Championship MVP"
1220:                       />
1221:                       {hasEdited && validationErrors.title ? (
1222:                         <span className="mt-1 block text-[11px] text-rose-300">
1223:                           {validationErrors.title}
1224:                         </span>
1225:                       ) : null}
1226:                     </label>
1227:                     <label className="text-xs uppercase tracking-wide text-slate-400 sm:col-span-2">
1228:                       Caption
1229:                       <textarea
1230:                         value={form.caption}
1231:                         onChange={handleFieldChange('caption')}
1232:                         maxLength={MAX_CAPTION_LENGTH}
1233:                         rows={2}
1234:                         className={inputClass(hasEdited && Boolean(validationErrors.caption))}
1235:                         placeholder="Awarded to the tournament MVP"
1236:                       />
1237:                       {hasEdited && validationErrors.caption ? (
1238:                         <span className="mt-1 block text-[11px] text-rose-300">
1239:                           {validationErrors.caption}
1240:                         </span>
1241:                       ) : null}
1242:                     </label>
1243:                   </>
1244:                 ) : (
1245:                   <>
1246:                     {cardTypeConfig?.showTeamField ? (
1247:                       <label className="text-xs uppercase tracking-wide text-slate-400">
1248:                         Team <span className="text-rose-400">*</span>
1249:                         <select
1250:                           value={form.teamId}
1251:                           onChange={handleFieldChange('teamId')}
1252:                           className={inputClass(hasEdited && Boolean(validationErrors.teamId))}
1253:                         >
1254:                           <option value="">Select team</option>
1255:                           {tournamentConfig?.teams.map((team) => (
1256:                             <option key={team.id} value={team.id}>
1257:                               {team.name}
1258:                             </option>
1259:                           ))}
1260:                         </select>
1261:                         {hasEdited && validationErrors.teamId ? (
1262:                           <span className="mt-1 block text-[11px] text-rose-300">
1263:                             {validationErrors.teamId}
1264:                           </span>
1265:                         ) : null}
1266:                         {selectedTeam?.logoKey ? (
1267:                           <img
1268:                             src={assetUrlForKey(selectedTeam.logoKey)}
1269:                             alt={`${selectedTeam.name} logo`}
1270:                             className="mt-2 h-10 w-10 rounded-lg border border-white/10 object-contain"
1271:                           />
1272:                         ) : null}
1273:                       </label>
1274:                     ) : null}
1275:                     <label className="text-xs uppercase tracking-wide text-slate-400">
1276:                       Position <span className="text-rose-400">*</span>
1277:                       {cardTypeConfig?.positions && cardTypeConfig.positions.length > 0 ? (
1278:                         <select
1279:                           value={form.position}
1280:                           onChange={handleFieldChange('position')}
1281:                           className={inputClass(hasEdited && Boolean(validationErrors.position))}
1282:                         >
1283:                           <option value="">Select position</option>
1284:                           {cardTypeConfig.positions.map((option) => (
1285:                             <option key={option} value={option}>
1286:                               {option}
1287:                             </option>
1288:                           ))}
1289:                         </select>
1290:                       ) : (
1291:                         <input
1292:                           value={form.position}
1293:                           onChange={handleFieldChange('position')}
1294:                           maxLength={MAX_POSITION_LENGTH}
1295:                           className={inputClass(hasEdited && Boolean(validationErrors.position))}
1296:                           placeholder="Keeper"
1297:                         />
1298:                       )}
1299:                       {hasEdited && validationErrors.position ? (
1300:                         <span className="mt-1 block text-[11px] text-rose-300">
1301:                           {validationErrors.position}
1302:                         </span>
1303:                       ) : null}
1304:                     </label>
1305:                     {cardTypeConfig?.showJerseyNumber ? (
1306:                       <label className="text-xs uppercase tracking-wide text-slate-400">
1307:                         Jersey Number
1308:                         <input
1309:                           value={form.jerseyNumber}
1310:                           onChange={handleFieldChange('jerseyNumber')}
1311:                           maxLength={MAX_JERSEY_LENGTH}
1312:                           inputMode="numeric"
1313:                           pattern="\\d*"
1314:                           className={inputClass(hasEdited && Boolean(validationErrors.jerseyNumber))}
1315:                           placeholder="15"
1316:                         />
1317:                         {hasEdited && validationErrors.jerseyNumber ? (
1318:                           <span className="mt-1 block text-[11px] text-rose-300">
1319:                             {validationErrors.jerseyNumber}
1320:                           </span>
1321:                         ) : (
1322:                           <span className="mt-1 block text-[11px] text-slate-500">
1323:                             Numbers only, up to 2 digits.
1324:                           </span>
1325:                         )}
1326:                       </label>
1327:                     ) : null}
1328:                     <label className="text-xs uppercase tracking-wide text-slate-400">
1329:                       First Name <span className="text-rose-400">*</span>
1330:                       <input
1331:                         value={form.firstName}
1332:                         onChange={handleFieldChange('firstName')}
1333:                         maxLength={MAX_NAME_LENGTH}
1334:                         className={inputClass(hasEdited && Boolean(validationErrors.firstName))}
1335:                         placeholder="Brandon"
1336:                       />
1337:                       {hasEdited && validationErrors.firstName ? (
1338:                         <span className="mt-1 block text-[11px] text-rose-300">
1339:                           {validationErrors.firstName}
1340:                         </span>
1341:                       ) : null}
1342:                     </label>
1343:                     <label className="text-xs uppercase tracking-wide text-slate-400">
1344:                       Last Name <span className="text-rose-400">*</span>
1345:                       <input
1346:                         value={form.lastName}
1347:                         onChange={handleFieldChange('lastName')}
1348:                         maxLength={MAX_NAME_LENGTH}
1349:                         className={inputClass(hasEdited && Boolean(validationErrors.lastName))}
1350:                         placeholder="Williams"
1351:                       />
1352:                       {hasEdited && validationErrors.lastName ? (
1353:                         <span className="mt-1 block text-[11px] text-rose-300">
1354:                           {validationErrors.lastName}
1355:                         </span>
1356:                       ) : null}
1357:                     </label>
1358:                   </>
1359:                 )}
1360:                 <label className="text-xs uppercase tracking-wide text-slate-400 sm:col-span-2">
1361:                   Photo Credit
1362:                   <input
1363:                     value={form.photographer}
1364:                     onChange={handleFieldChange('photographer')}
1365:                     maxLength={MAX_PHOTOGRAPHER_LENGTH}
1366:                     className="mt-2 w-full rounded-xl border border-white/10 bg-slate-950/60 px-3 py-2 text-sm text-white"
1367:                     placeholder="Paul Schiopu"
1368:                   />
1369:                 </label>
1370:               </form>
1371:               <div className="mt-6">
1372:                 <label className="text-xs uppercase tracking-wide text-slate-400">
1373:                   Card Photo <span className="text-rose-400">*</span>
1374:                 </label>
1375:                 <label
1376:                   className={`mt-3 flex cursor-pointer flex-col items-center justify-center gap-2 rounded-2xl border border-dashed px-6 py-8 text-center text-sm text-slate-300 transition ${
1377:                     isDragging ? 'border-emerald-400/70 bg-emerald-500/10' : 'border-white/15 bg-slate-950/40'
1378:                   }`}
1379:                   onClick={handleUploadClick}
1380:                   onDrop={handleDrop}
1381:                   onDragOver={handleDragOver}
1382:                   onDragLeave={handleDragLeave}
1383:                 >
1384:                   <input
1385:                     type="file"
1386:                     accept="image/jpeg,image/png,image/webp"
1387:                     className="sr-only"
1388:                     onChange={handleFileChange}
1389:                     ref={fileInputRef}
1390:                   />
1391:                   <div className="flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-slate-400">
1392:                     Drop photo here
1393:                   </div>
1394:                   <p className="text-xs text-slate-500">
1395:                     or click to upload (JPG, PNG, WebP · max 15MB)
1396:                   </p>
1397:                   {photo ? (
1398:                     <p className="text-xs text-emerald-300">
1399:                       {photo.file.name} · {photo.width} x {photo.height} px
1400:                     </p>
1401:                   ) : (
1402:                     <p className="text-xs text-slate-500">Auto-resized to {MAX_IMAGE_DIMENSION}px max</p>
1403:                   )}
1404:                 </label>
1405:                 <div className="mt-2 flex flex-wrap items-center gap-3 text-xs text-slate-400">
1406:                   <span>{photo ? photo.file.name : 'No file selected'}</span>
1407:                   {uploadedPhoto && <span className="text-emerald-400">Uploaded</span>}
1408:                 </div>
1409:                 {photoError ? (
1410:                   <p className="mt-2 text-xs text-rose-300">{photoError}</p>
1411:                 ) : hasEdited && validationErrors.photo ? (
1412:                   <p className="mt-2 text-xs text-rose-300">{validationErrors.photo}</p>
1413:                 ) : null}
1414:               </div>
1415:               <div className="mt-6 flex flex-wrap items-center gap-4">
1416:                 <button
1417:                   type="button"
1418:                   onClick={handleSaveDraft}
1419:                   disabled={saveMutation.isPending}
1420:                   className="rounded-full bg-white px-5 py-2 text-xs font-semibold text-slate-900 transition hover:bg-slate-100 disabled:cursor-not-allowed disabled:opacity-70"
1421:                 >
1422:                   {saveButtonLabel}
1423:                 </button>
1424:                 <button
1425:                   type="button"
1426:                   onClick={() => submitMutation.mutate()}
1427:                   disabled={!canSubmit}
1428:                   className="rounded-full bg-emerald-500 px-5 py-2 text-xs font-semibold text-white transition hover:bg-emerald-400 disabled:cursor-not-allowed disabled:opacity-50"
1429:                 >
1430:                   {submitButtonLabel}
1431:                 </button>
1432:                 <span className="text-xs text-slate-500">
1433:                   Submit saves a draft automatically.
1434:                 </span>
1435:                 <div className="flex flex-wrap items-center gap-3 text-xs">
1436:                   <span className={statusToneClass}>{statusIndicator.message}</span>
1437:                   {uploadProgress ? (
1438:                     <div className="flex items-center gap-2">
1439:                       <div
1440:                         className="h-1 w-24 overflow-hidden rounded-full bg-white/10"
1441:                         role="progressbar"
1442:                         aria-valuemin={0}
1443:                         aria-valuemax={100}
1444:                         aria-valuenow={uploadProgress.percent}
1445:                       >
1446:                         <div
1447:                           className="h-full rounded-full bg-emerald-400 transition-all"
1448:                           style={{ width: `${uploadProgress.percent}%` }}
1449:                         />
1450:                       </div>
1451:                       <span className="text-[11px] text-slate-400">
1452:                         Photo{' '}
1453:                         {uploadProgress.percent}%
1454:                       </span>
1455:                     </div>
1456:                   ) : null}
1457:                 </div>
1458:               </div>
1459:             </section>
1460:             <section className="space-y-6">
1461:               <div
1462:                 className={`rounded-3xl border border-emerald-500/30 bg-emerald-950/20 p-6 backdrop-blur ${
1463:                   submitStatus === 'done' ? 'celebrate' : ''
1464:                 }`}
1465:               >
1466:                 <div className="flex items-center justify-between gap-3">
1467:                   <h3 className="text-sm uppercase tracking-[0.2em] text-emerald-400">
1468:                     {renderedCardUrl ? 'Rendered Card' : 'Live Preview'}
1469:                   </h3>
1470:                   {previewUrl && !renderedCardUrl ? (
1471:                     <span className="text-xs text-emerald-200/70">Updating preview</span>
1472:                   ) : null}
1473:                 </div>
1474:                 {renderedCardUrl ? (
1475:                   <>
1476:                     <div className="mt-4">
1477:                       <img
1478:                         src={renderedCardUrl}
1479:                         alt="Rendered trading card"
1480:                         className="w-full rounded-2xl shadow-lg"
1481:                       />
1482:                     </div>
1483:                     <div className="mt-4 flex flex-wrap items-center gap-3">
1484:                       <a
1485:                         href={renderedCardUrl}
1486:                         download="trading-card.png"
1487:                         className="rounded-full border border-emerald-500/30 px-4 py-2 text-xs text-emerald-400 transition hover:border-emerald-500/60 hover:bg-emerald-500/10"
1488:                       >
1489:                         Download PNG
1490:                       </a>
1491:                       <span className="text-xs text-slate-400">
1492:                         Status: {savedCard?.status ?? 'unknown'}
1493:                       </span>
1494:                     </div>
1495:                   </>
1496:                 ) : previewUrl ? (
1497:                   <div className="mt-4">
1498:                     <img
1499:                       src={previewUrl}
1500:                       alt="Live preview trading card"
1501:                       className="w-full rounded-2xl shadow-lg"
1502:                     />
1503:                     <p className="mt-2 text-xs text-slate-400">
1504:                       Preview updates as you edit. Submit to send for rendering.
1505:                     </p>
1506:                   </div>
1507:                 ) : (
1508:                   <div className="mt-4">
1509:                     <div className="flex aspect-[825/1125] w-full items-center justify-center rounded-2xl border border-dashed border-emerald-500/30 bg-slate-950/50 text-xs text-emerald-200/70">
1510:                       {isSubmitInProgress ? (
1511:                         <div className="flex flex-col items-center gap-3 text-emerald-200/70">
1512:                           <div className="h-10 w-10 animate-spin rounded-full border border-emerald-400/40 border-t-transparent" />
1513:                           <span className="text-[11px] uppercase tracking-[0.2em]">
1514:                             Submitting card
1515:                           </span>
1516:                         </div>
1517:                       ) : previewError ? (
1518:                         previewError
1519:                       ) : (
1520:                         'Upload a photo and crop to see the live preview.'
1521:                       )}
1522:                     </div>
1523:                   </div>
1524:                 )}
1525:               </div>
1526:               <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
1527:                 <div>
1528:                   <h2 className="text-lg font-semibold text-white">Live Crop</h2>
1529:                   <p className="text-sm text-slate-400">
1530:                     Drag the image to frame it. Scroll or pinch to zoom.
1531:                   </p>
1532:                 </div>
1533:                 <div className="mt-5">
1534:                   <div className="relative aspect-[825/1125] w-full overflow-hidden rounded-[28px] border border-white/10 bg-slate-950/60 shadow-[0_20px_60px_rgba(3,7,18,0.6)]">
1535:                     {cropperImageUrl ? (
1536:                       <Cropper
1537:                         image={cropperImageUrl}
1538:                         crop={crop}
1539:                         zoom={zoom}
1540:                         rotation={0}
1541:                         aspect={CARD_ASPECT}
1542:                         onCropChange={setCrop}
1543:                         onZoomChange={setZoom}
1544:                         onCropComplete={handleCropComplete}
1545:                         onMediaLoaded={handleMediaLoaded}
1546:                         showGrid={false}
1547:                         classes={{
1548:                           containerClassName: 'cropper-container',
1549:                           cropAreaClassName: 'cropper-area',
1550:                         }}
1551:                       />
1552:                     ) : (
1553:                       <div className="flex h-full w-full items-center justify-center text-sm text-slate-400">
1554:                         Upload a photo to start cropping
1555:                       </div>
1556:                     )}
1557:                     <CropGuides visible={showGuides} />
1558:                   </div>
1559:                   {hasEdited && validationErrors.crop ? (
1560:                     <p className="mt-2 text-xs text-rose-300">{validationErrors.crop}</p>
1561:                   ) : null}
1562:                 </div>
1563:                 <div className="mt-5 flex flex-wrap items-center gap-3">
1564:                   <button
1565:                     type="button"
1566:                     onClick={() => handleZoom(0.2)}
1567:                     className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
1568:                   >
1569:                     Zoom In
1570:                   </button>
1571:                   <button
1572:                     type="button"
1573:                     onClick={() => handleZoom(-0.2)}
1574:                     className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
1575:                   >
1576:                     Zoom Out
1577:                   </button>
1578:                   <button
1579:                     type="button"
1580:                     onClick={handleResetCrop}
1581:                     className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
1582:                   >
1583:                     Reset
1584:                   </button>
1585:                   <button
1586:                     type="button"
1587:                     onClick={() => setShowGuides((prev) => !prev)}
1588:                     className="rounded-full border border-white/15 px-3 py-1 text-xs text-white transition hover:border-white/40"
1589:                   >
1590:                     {showGuides ? 'Hide Guides' : 'Show Guides'}
1591:                   </button>
1592:                 </div>
1593:               </div>
1594:               <div className="rounded-3xl border border-white/10 bg-white/5 p-6 backdrop-blur">
1595:                 <h3 className="text-sm uppercase tracking-[0.2em] text-slate-400">
1596:                   Preview Meta
1597:                 </h3>
1598:                 <div className="mt-4 space-y-3">
1599:                   <div className="font-display text-2xl text-white">{displayName}</div>
1600:                   <div className="text-sm text-slate-300">
1601:                     {form.cardType === 'rare'
1602:                       ? form.caption || 'Caption'
1603:                       : [form.position || 'Position', selectedTeam?.name || (cardTypeConfig?.showTeamField ? 'Team' : '')]
1604:                           .filter(Boolean)
1605:                           .join(' / ')}
1606:                   </div>
1607:                   <div className="text-xs text-slate-400">
1608:                     Crop: {normalizedCrop ? `${normalizedCrop.w.toFixed(2)} x ${normalizedCrop.h.toFixed(2)}` : '-'}
1609:                   </div>
1610:                   {uploadedPhoto && (
1611:                     <div className="text-xs text-slate-400">
1612:                       Photo: <span className="text-emerald-400">{uploadedPhoto.key}</span>
1613:                     </div>
1614:                   )}
1615:                   {savedCard ? (
1616:                     <div className="rounded-2xl border border-white/10 bg-slate-950/60 px-4 py-3 text-xs text-slate-300">
1617:                       Saved as <span className="text-white">{savedCard.id}</span>
1618:                     </div>
1619:                   ) : null}
1620:                 </div>
1621:               </div>
1622:             </section>
1623:           </div>
1624:         )}
1625:       </div>
1626:     </div>
1627:   )
1628: }
1629: export default App
</file>

<file path="server/src/index.ts">
   1: import { Hono, type MiddlewareHandler } from 'hono'
   2: import { Resource } from 'sst'
   3: import { randomUUID } from 'node:crypto'
   4: import { Readable } from 'node:stream'
   5: import { text as streamToText } from 'node:stream/consumers'
   6: import JSZip from 'jszip'
   7: import { createPresignedPost } from '@aws-sdk/s3-presigned-post'
   8: import { getSignedUrl } from '@aws-sdk/s3-request-presigner'
   9: import { GetObjectCommand, HeadObjectCommand, PutObjectCommand, S3Client } from '@aws-sdk/client-s3'
  10: import { ConditionalCheckFailedException, DynamoDBClient } from '@aws-sdk/client-dynamodb'
  11: import { DynamoDBDocumentClient, GetCommand, PutCommand, QueryCommand, UpdateCommand, DeleteCommand } from '@aws-sdk/lib-dynamodb'
  12: import type { ApiResponse, Card, CardStatus, CardType, CropRect, RenderMeta, TournamentConfig, TournamentListEntry } from 'shared'
  13: import {
  14:   ALLOWED_RENDER_TYPES as ALLOWED_RENDER_TYPES_LIST,
  15:   ALLOWED_UPLOAD_TYPES as ALLOWED_UPLOAD_TYPES_LIST,
  16:   JERSEY_PATTERN,
  17:   MAX_CAPTION_LENGTH,
  18:   MAX_NAME_LENGTH,
  19:   MAX_PHOTOGRAPHER_LENGTH,
  20:   MAX_POSITION_LENGTH,
  21:   MAX_TEAM_LENGTH,
  22:   MAX_TITLE_LENGTH,
  23:   MAX_UPLOAD_BYTES,
  24:   USQC_2025_CONFIG,
  25:   USQC_2025_TOURNAMENT,
  26: } from 'shared'
  27: const app = new Hono()
  28: const RATE_LIMIT_WINDOW_MS = 60_000
  29: const RATE_LIMIT_MAX = 180
  30: const rateLimitMap = new Map<string, { count: number; resetAt: number }>()
  31: const adminAuthFailures = new Map<string, { count: number; resetAt: number }>()
  32: const getClientIp = (c: { req: { header: (name: string) => string | undefined } }) =>
  33:   c.req.header('x-forwarded-for')?.split(',')[0]?.trim() ||
  34:   c.req.header('cf-connecting-ip') ||
  35:   c.req.header('x-real-ip') ||
  36:   'unknown'
  37: const shouldRateLimit = (method: string) =>
  38:   method === 'POST' || method === 'PUT' || method === 'PATCH' || method === 'DELETE'
  39: const s3 = new S3Client({})
  40: const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}))
  41: const ALLOWED_UPLOAD_TYPES: Set<string> = new Set(ALLOWED_UPLOAD_TYPES_LIST)
  42: const ALLOWED_RENDER_TYPES: Set<string> = new Set(ALLOWED_RENDER_TYPES_LIST)
  43: const RENDER_EXTENSION = 'png'
  44: const CONFIG_LIST_KEY = 'config/tournaments.json'
  45: const CONFIG_PREFIX = 'config/tournaments'
  46: const MAX_TEMPLATE_LENGTH = 32
  47: const EDIT_TOKEN_HEADER = 'x-edit-token'
  48: const ADMIN_AUTH_WINDOW_MS = 10 * 60_000
  49: const ADMIN_AUTH_MAX_FAILURES = 24
  50: const CARD_TYPES: CardType[] = [
  51:   'player',
  52:   'team-staff',
  53:   'media',
  54:   'official',
  55:   'tournament-staff',
  56:   'rare',
  57: ]
  58: type PresignKind = 'original' | 'crop' | 'render'
  59: type PresignRequest = {
  60:   cardId: string
  61:   contentType: string
  62:   contentLength: number
  63:   kind: PresignKind
  64: }
  65: type CardInput = Partial<Card> & {
  66:   firstName?: string
  67:   lastName?: string
  68:   title?: string
  69:   caption?: string
  70:   teamId?: string
  71:   teamName?: string
  72:   position?: string
  73:   jerseyNumber?: string
  74:   templateId?: string
  75: }
  76: const isRecord = (value: unknown): value is Record<string, unknown> =>
  77:   typeof value === 'object' && value !== null && !Array.isArray(value)
  78: const nowIso = () => new Date().toISOString()
  79: const isCardStatus = (value: unknown): value is CardStatus =>
  80:   value === 'draft' || value === 'submitted' || value === 'rendered'
  81: const SAFE_ID_PATTERN = /^[a-z0-9-]{3,64}$/
  82: const isSafeId = (value: unknown): value is string =>
  83:   typeof value === 'string' && SAFE_ID_PATTERN.test(value)
  84: const isCardType = (value: unknown): value is CardType =>
  85:   typeof value === 'string' && CARD_TYPES.includes(value as CardType)
  86: const toNumber = (value: unknown): number | undefined => {
  87:   if (typeof value === 'number' && Number.isFinite(value)) {
  88:     return value
  89:   }
  90:   if (typeof value === 'string' && value.trim() !== '') {
  91:     const parsed = Number(value)
  92:     return Number.isFinite(parsed) ? parsed : undefined
  93:   }
  94:   return undefined
  95: }
  96: const toRotateDeg = (value: unknown): CropRect['rotateDeg'] | undefined => {
  97:   const numeric = toNumber(value)
  98:   if (numeric === 0 || numeric === 90 || numeric === 180 || numeric === 270) {
  99:     return numeric
 100:   }
 101:   return undefined
 102: }
 103: const clamp = (n: number, min: number, max: number) => Math.min(Math.max(n, min), max)
 104: const normalizeString = (value: unknown) => {
 105:   if (typeof value !== 'string') return undefined
 106:   const trimmed = value.trim()
 107:   return trimmed.length > 0 ? trimmed : undefined
 108: }
 109: const ensureMaxLength = (value: string, max: number, label: string) => {
 110:   if (value.length > max) {
 111:     return `${label} must be ${max} characters or fewer`
 112:   }
 113:   return null
 114: }
 115: const buildStatusCreatedAt = (status: CardStatus, createdAt: string) => `${status}#${createdAt}`
 116: const pickCrop = (value: unknown): CropRect | undefined => {
 117:   if (!isRecord(value)) return undefined
 118:   const rawX = toNumber(value.x)
 119:   const rawY = toNumber(value.y)
 120:   const rawW = toNumber(value.w)
 121:   const rawH = toNumber(value.h)
 122:   if (rawX === undefined || rawY === undefined || rawW === undefined || rawH === undefined) {
 123:     return undefined
 124:   }
 125:   const x = clamp(rawX, 0, 1)
 126:   const y = clamp(rawY, 0, 1)
 127:   const w = clamp(rawW, 0.001, 1)
 128:   const h = clamp(rawH, 0.001, 1)
 129:   const clampedW = Math.min(w, 1 - x)
 130:   const clampedH = Math.min(h, 1 - y)
 131:   const rotateDeg = toRotateDeg(value.rotateDeg) ?? 0
 132:   return { x, y, w: clampedW, h: clampedH, rotateDeg }
 133: }
 134: const pickPhoto = (value: unknown): Card['photo'] | undefined => {
 135:   if (!isRecord(value)) return undefined
 136:   const photo: Card['photo'] = {}
 137:   const originalKey = normalizeString(value.originalKey)
 138:   const cropKey = normalizeString(value.cropKey)
 139:   if (originalKey) photo.originalKey = originalKey
 140:   if (cropKey) photo.cropKey = cropKey
 141:   const width = toNumber(value.width)
 142:   const height = toNumber(value.height)
 143:   if (width !== undefined) photo.width = width
 144:   if (height !== undefined) photo.height = height
 145:   const crop = pickCrop(value.crop)
 146:   if (crop) photo.crop = crop
 147:   return Object.keys(photo).length > 0 ? photo : undefined
 148: }
 149: const isValidDimension = (value: unknown): value is number =>
 150:   typeof value === 'number' && Number.isFinite(value) && value > 0
 151: const isValidCropRect = (crop?: CropRect) => {
 152:   if (!crop) return false
 153:   const { x, y, w, h, rotateDeg } = crop
 154:   if (![x, y, w, h].every((value) => typeof value === 'number' && Number.isFinite(value))) {
 155:     return false
 156:   }
 157:   const rotateOk = rotateDeg === 0 || rotateDeg === 90 || rotateDeg === 180 || rotateDeg === 270
 158:   if (!rotateOk) return false
 159:   if (x < 0 || y < 0 || x > 1 || y > 1) return false
 160:   if (w <= 0 || h <= 0 || w > 1 || h > 1) return false
 161:   if (x + w > 1 || y + h > 1) return false
 162:   return true
 163: }
 164: const validatePhotoKeys = (cardId: string, photo?: Card['photo']) => {
 165:   if (!photo) return null
 166:   if (photo.originalKey && !photo.originalKey.startsWith(`uploads/original/${cardId}/`)) {
 167:     return 'originalKey must belong to this card'
 168:   }
 169:   if (photo.cropKey && !photo.cropKey.startsWith(`uploads/crop/${cardId}/`)) {
 170:     return 'cropKey must belong to this card'
 171:   }
 172:   return null
 173: }
 174: const TEMPLATE_THEME_KEYS = [
 175:   'gradientStart',
 176:   'gradientEnd',
 177:   'border',
 178:   'accent',
 179:   'label',
 180:   'nameColor',
 181:   'meta',
 182:   'watermark',
 183: ] as const
 184: const TEMPLATE_FLAG_KEYS = [
 185:   'showGradient',
 186:   'showBorders',
 187:   'showWatermarkJersey',
 188: ] as const
 189: const parseRenderMeta = (value: unknown, renderKey: string): RenderMeta | string => {
 190:   if (!isRecord(value)) return 'renderMeta must be an object'
 191:   const templateId = normalizeString(value.templateId)
 192:   if (!templateId) return 'renderMeta.templateId is required'
 193:   const renderedAt = normalizeString(value.renderedAt)
 194:   if (!renderedAt) return 'renderMeta.renderedAt is required'
 195:   const key = normalizeString(value.key) ?? renderKey
 196:   if (key !== renderKey) return 'renderMeta.key must match renderKey'
 197:   if (!isRecord(value.templateSnapshot)) return 'renderMeta.templateSnapshot is required'
 198:   const snapshot = value.templateSnapshot
 199:   const overlayKey = normalizeString(snapshot.overlayKey)
 200:   if (!isRecord(snapshot.theme)) return 'renderMeta.templateSnapshot.theme is required'
 201:   const themeSource = snapshot.theme
 202:   const theme = {} as RenderMeta['templateSnapshot']['theme']
 203:   for (const field of TEMPLATE_THEME_KEYS) {
 204:     const raw = normalizeString(themeSource[field])
 205:     if (!raw) return `renderMeta.templateSnapshot.theme.${field} is required`
 206:     theme[field] = raw
 207:   }
 208:   if (!isRecord(snapshot.flags)) return 'renderMeta.templateSnapshot.flags is required'
 209:   const flagsSource = snapshot.flags
 210:   const flags = {} as RenderMeta['templateSnapshot']['flags']
 211:   for (const field of TEMPLATE_FLAG_KEYS) {
 212:     const raw = flagsSource[field]
 213:     if (typeof raw !== 'boolean') {
 214:       return `renderMeta.templateSnapshot.flags.${field} must be a boolean`
 215:     }
 216:     flags[field] = raw
 217:   }
 218:   const overlayPlacement = normalizeString(snapshot.overlayPlacement)
 219:   if (overlayPlacement !== 'belowText' && overlayPlacement !== 'aboveText') {
 220:     return 'renderMeta.templateSnapshot.overlayPlacement is invalid'
 221:   }
 222:   return {
 223:     key,
 224:     templateId,
 225:     renderedAt,
 226:     templateSnapshot: {
 227:       overlayKey: overlayKey ?? undefined,
 228:       theme,
 229:       flags,
 230:       overlayPlacement,
 231:     },
 232:   }
 233: }
 234: const validateCardFields = (card: CardInput) => {
 235:   if (card.firstName) {
 236:     const error = ensureMaxLength(card.firstName, MAX_NAME_LENGTH, 'firstName')
 237:     if (error) return error
 238:   }
 239:   if (card.lastName) {
 240:     const error = ensureMaxLength(card.lastName, MAX_NAME_LENGTH, 'lastName')
 241:     if (error) return error
 242:   }
 243:   if (card.title) {
 244:     const error = ensureMaxLength(card.title, MAX_TITLE_LENGTH, 'title')
 245:     if (error) return error
 246:   }
 247:   if (card.caption) {
 248:     const error = ensureMaxLength(card.caption, MAX_CAPTION_LENGTH, 'caption')
 249:     if (error) return error
 250:   }
 251:   if (card.photographer) {
 252:     const error = ensureMaxLength(card.photographer, MAX_PHOTOGRAPHER_LENGTH, 'photographer')
 253:     if (error) return error
 254:   }
 255:   if (card.teamName) {
 256:     const error = ensureMaxLength(card.teamName, MAX_TEAM_LENGTH, 'teamName')
 257:     if (error) return error
 258:   }
 259:   if (card.teamId) {
 260:     const error = ensureMaxLength(card.teamId, MAX_TEAM_LENGTH, 'teamId')
 261:     if (error) return error
 262:   }
 263:   if (card.position) {
 264:     const error = ensureMaxLength(card.position, MAX_POSITION_LENGTH, 'position')
 265:     if (error) return error
 266:   }
 267:   if (card.templateId) {
 268:     const error = ensureMaxLength(card.templateId, MAX_TEMPLATE_LENGTH, 'templateId')
 269:     if (error) return error
 270:   }
 271:   if (card.jerseyNumber && !JERSEY_PATTERN.test(card.jerseyNumber)) {
 272:     return 'jerseyNumber must be 1-2 digits'
 273:   }
 274:   return null
 275: }
 276: const getSubmitValidationError = (card: Card) => {
 277:   if (!card.tournamentId) return 'tournamentId is required before submitting'
 278:   if (!card.cardType || !isCardType(card.cardType)) {
 279:     return 'cardType is required before submitting'
 280:   }
 281:   const fieldError = validateCardFields(card)
 282:   if (fieldError) return fieldError
 283:   const photo = card.photo
 284:   if (!photo) return 'photo is required before submitting'
 285:   if (!photo.originalKey) return 'photo.originalKey is required before submitting'
 286:   if (!isValidDimension(photo.width) || !isValidDimension(photo.height)) {
 287:     return 'photo dimensions are required before submitting'
 288:   }
 289:   if (!isValidCropRect(photo.crop)) return 'photo.crop is required before submitting'
 290:   switch (card.cardType) {
 291:     case 'rare':
 292:       if (!card.title) return 'title is required before submitting'
 293:       break
 294:     default:
 295:       if (!card.firstName) return 'firstName is required before submitting'
 296:       if (!card.lastName) return 'lastName is required before submitting'
 297:       if (!card.position) return 'position is required before submitting'
 298:       break
 299:   }
 300:   if (card.cardType === 'player' || card.cardType === 'team-staff') {
 301:     if (!card.teamId && !card.teamName) {
 302:       return 'team is required before submitting'
 303:     }
 304:   }
 305:   return null
 306: }
 307: const pickCardInput = (
 308:   input: Record<string, unknown>,
 309:   options?: { allowStatus?: boolean }
 310: ): CardInput => {
 311:   const data: CardInput = {}
 312:   const cardType = normalizeString(input.cardType) ?? normalizeString(input.type)
 313:   if (cardType && isCardType(cardType)) data.cardType = cardType
 314:   const tournamentId = normalizeString(input.tournamentId)
 315:   if (tournamentId) data.tournamentId = tournamentId
 316:   const templateId = normalizeString(input.templateId)
 317:   if (templateId) data.templateId = templateId
 318:   const teamId = normalizeString(input.teamId)
 319:   if (teamId) data.teamId = teamId
 320:   const teamName = normalizeString(input.teamName)
 321:   if (teamName) data.teamName = teamName
 322:   const position = normalizeString(input.position)
 323:   if (position) data.position = position
 324:   const jerseyNumber = normalizeString(input.jerseyNumber)
 325:   if (jerseyNumber) data.jerseyNumber = jerseyNumber
 326:   const firstName = normalizeString(input.firstName)
 327:   if (firstName) data.firstName = firstName
 328:   const lastName = normalizeString(input.lastName)
 329:   if (lastName) data.lastName = lastName
 330:   const photographer = normalizeString(input.photographer)
 331:   if (photographer) data.photographer = photographer
 332:   const title = normalizeString(input.title)
 333:   if (title) data.title = title
 334:   const caption = normalizeString(input.caption)
 335:   if (caption) data.caption = caption
 336:   const photo = pickPhoto(input.photo)
 337:   if (photo) data.photo = photo
 338:   if (options?.allowStatus && isCardStatus(input.status)) {
 339:     data.status = input.status
 340:   }
 341:   return data
 342: }
 343: const getExtension = (contentType: string) => {
 344:   switch (contentType) {
 345:     case 'image/jpeg':
 346:       return 'jpg'
 347:     case 'image/png':
 348:       return 'png'
 349:     case 'image/webp':
 350:       return 'webp'
 351:     default:
 352:       return null
 353:   }
 354: }
 355: const getUploadKey = (cardId: string, kind: PresignKind, contentType: string) => {
 356:   const uploadId = randomUUID().slice(0, 8)
 357:   if (kind === 'render') {
 358:     return `renders/${cardId}/${uploadId}.${RENDER_EXTENSION}`
 359:   }
 360:   const ext = getExtension(contentType)
 361:   if (!ext) return null
 362:   const prefix = kind === 'original' ? 'uploads/original' : 'uploads/crop'
 363:   return `${prefix}/${cardId}/${uploadId}.${ext}`
 364: }
 365: const getPublicPath = (key: string) => {
 366:   if (key.startsWith('renders/')) {
 367:     return `/r/${key.slice('renders/'.length)}`
 368:   }
 369:   if (key.startsWith('config/')) {
 370:     return `/c/${key.slice('config/'.length)}`
 371:   }
 372:   return null
 373: }
 374: const toPublicCard = (card: Card) => {
 375:   const { photo, editToken, ...rest } = card
 376:   if (!photo?.crop) {
 377:     return rest
 378:   }
 379:   return {
 380:     ...rest,
 381:     photo: {
 382:       crop: photo.crop,
 383:     },
 384:   }
 385: }
 386: const getJsonBody = async (c: { req: { json: () => Promise<unknown> } }) => {
 387:   try {
 388:     return await c.req.json()
 389:   } catch {
 390:     return null
 391:   }
 392: }
 393: const badRequest = (c: { json: (data: unknown, status?: number) => Response }, message: string) =>
 394:   c.json({ error: message }, 400)
 395: const bodyToString = async (body: unknown) => {
 396:   if (!body) return ''
 397:   if (typeof body === 'string') return body
 398:   if (body instanceof Uint8Array) return Buffer.from(body).toString('utf8')
 399:   if (body instanceof ArrayBuffer) return Buffer.from(new Uint8Array(body)).toString('utf8')
 400:   if (ArrayBuffer.isView(body)) return Buffer.from(body.buffer).toString('utf8')
 401:   if (body && typeof (body as { transformToString?: () => Promise<string> }).transformToString === 'function') {
 402:     return (body as { transformToString: () => Promise<string> }).transformToString()
 403:   }
 404:   if (body instanceof Readable) {
 405:     return streamToText(body)
 406:   }
 407:   return ''
 408: }
 409: const readJsonFromS3 = async <T>(key: string): Promise<T | null> => {
 410:   try {
 411:     const result = await s3.send(
 412:       new GetObjectCommand({
 413:         Bucket: Resource.Media.name,
 414:         Key: key,
 415:       })
 416:     )
 417:     const text = await bodyToString(result.Body)
 418:     return text ? (JSON.parse(text) as T) : null
 419:   } catch (err) {
 420:     const name = isRecord(err) ? String(err.name ?? '') : ''
 421:     if (name === 'NoSuchKey' || name === 'NotFound') return null
 422:     throw err
 423:   }
 424: }
 425: const writeJsonToS3 = async (key: string, value: unknown, options?: { cacheControl?: string }) => {
 426:   await s3.send(
 427:     new PutObjectCommand({
 428:       Bucket: Resource.Media.name,
 429:       Key: key,
 430:       Body: JSON.stringify(value, null, 2),
 431:       ContentType: 'application/json',
 432:       CacheControl: options?.cacheControl ?? 'no-store',
 433:     })
 434:   )
 435: }
 436: const getConfigKey = (tournamentId: string, stage: 'draft' | 'published') =>
 437:   `${CONFIG_PREFIX}/${tournamentId}/${stage}/config.json`
 438: type UpdateDraft = {
 439:   set: Record<string, unknown>
 440:   remove: string[]
 441: }
 442: const pushSet = (draft: UpdateDraft, path: string, value: unknown) => {
 443:   draft.set[path] = value
 444:   draft.remove = draft.remove.filter((entry) => entry !== path)
 445: }
 446: const pushRemove = (draft: UpdateDraft, path: string) => {
 447:   if (!draft.remove.includes(path)) {
 448:     draft.remove.push(path)
 449:   }
 450:   delete draft.set[path]
 451: }
 452: const applyStringUpdate = (
 453:   draft: UpdateDraft,
 454:   value: unknown,
 455:   path: string,
 456:   maxLength: number,
 457:   label: string
 458: ) => {
 459:   if (value === undefined) return null
 460:   if (value === null) {
 461:     pushRemove(draft, path)
 462:     return null
 463:   }
 464:   if (typeof value !== 'string') return `${label} must be a string`
 465:   const trimmed = value.trim()
 466:   if (!trimmed) {
 467:     pushRemove(draft, path)
 468:     return null
 469:   }
 470:   const error = ensureMaxLength(trimmed, maxLength, label)
 471:   if (error) return error
 472:   pushSet(draft, path, trimmed)
 473:   return null
 474: }
 475: app.use('*', async (c, next) => {
 476:   if (shouldRateLimit(c.req.method) || c.req.path.startsWith('/admin/')) {
 477:     const ip = getClientIp(c)
 478:     const now = Date.now()
 479:     const entry = rateLimitMap.get(ip)
 480:     if (!entry || now > entry.resetAt) {
 481:       rateLimitMap.set(ip, { count: 1, resetAt: now + RATE_LIMIT_WINDOW_MS })
 482:     } else {
 483:       entry.count += 1
 484:       if (entry.count > RATE_LIMIT_MAX) {
 485:         return c.json({ error: 'Too many requests' }, 429)
 486:       }
 487:     }
 488:   }
 489:   await next()
 490: })
 491: const requireAdmin: MiddlewareHandler = async (c, next) => {
 492:   const auth = c.req.header('Authorization')
 493:   const expected = `Bearer ${Resource.AdminPassword.value}`
 494:   const ip = getClientIp(c)
 495:   const now = Date.now()
 496:   const failure = adminAuthFailures.get(ip)
 497:   if (failure && now <= failure.resetAt && failure.count > ADMIN_AUTH_MAX_FAILURES) {
 498:     return c.json({ error: 'Too many attempts' }, 429)
 499:   }
 500:   if (auth !== expected) {
 501:     const entry = adminAuthFailures.get(ip)
 502:     if (!entry || now > entry.resetAt) {
 503:       adminAuthFailures.set(ip, { count: 1, resetAt: now + ADMIN_AUTH_WINDOW_MS })
 504:     } else {
 505:       entry.count += 1
 506:       if (entry.count > ADMIN_AUTH_MAX_FAILURES) {
 507:         return c.json({ error: 'Too many attempts' }, 429)
 508:       }
 509:     }
 510:     return c.json({ error: 'Unauthorized' }, 401)
 511:   }
 512:   adminAuthFailures.delete(ip)
 513:   await next()
 514: }
 515: app.use('/admin/*', requireAdmin)
 516: const FALLBACK_TOURNAMENTS: TournamentListEntry[] = [USQC_2025_TOURNAMENT]
 517: const FALLBACK_CONFIGS: Record<string, TournamentConfig> = {
 518:   [USQC_2025_CONFIG.id]: USQC_2025_CONFIG,
 519: }
 520: app.get('/', (c) => c.text('Hello Hono!'))
 521: app.get('/hello', (c) => {
 522:   const data: ApiResponse = {
 523:     message: 'Hello BHVR!',
 524:     success: true,
 525:   }
 526:   return c.json(data, 200)
 527: })
 528: app.get('/tournaments', async (c) => {
 529:   const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
 530:   return c.json(list.filter((t) => t.published))
 531: })
 532: app.get('/tournaments/:id', async (c) => {
 533:   const id = c.req.param('id')
 534:   const config =
 535:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
 536:     FALLBACK_CONFIGS[id]
 537:   if (!config) {
 538:     return c.json({ error: 'Tournament not found' }, 404)
 539:   }
 540:   return c.json(config)
 541: })
 542: app.get('/tournaments/:id/teams', async (c) => {
 543:   const id = c.req.param('id')
 544:   const config =
 545:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
 546:     FALLBACK_CONFIGS[id]
 547:   if (!config) {
 548:     return c.json({ error: 'Tournament not found' }, 404)
 549:   }
 550:   return c.json(config.teams)
 551: })
 552: app.get('/admin/tournaments', async (c) => {
 553:   const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
 554:   return c.json(list)
 555: })
 556: app.get('/admin/tournaments/:id', async (c) => {
 557:   const id = c.req.param('id')
 558:   const draft = await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))
 559:   if (draft) return c.json(draft)
 560:   const published = await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))
 561:   if (published) return c.json(published)
 562:   const fallback = FALLBACK_CONFIGS[id]
 563:   if (fallback) return c.json(fallback)
 564:   return c.json({ error: 'Tournament not found' }, 404)
 565: })
 566: app.post('/admin/tournaments', async (c) => {
 567:   const body = await getJsonBody(c)
 568:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
 569:   const id = normalizeString(body.id)
 570:   const name = normalizeString(body.name)
 571:   const year = toNumber(body.year)
 572:   if (!id) return badRequest(c, 'id is required')
 573:   if (!isSafeId(id)) return badRequest(c, 'id must be 3-64 lowercase alphanumeric characters or hyphens')
 574:   if (!name) return badRequest(c, 'name is required')
 575:   if (!year || year < 2000) return badRequest(c, 'year is required')
 576:   const now = nowIso()
 577:   const baseConfig = JSON.parse(JSON.stringify(USQC_2025_CONFIG)) as TournamentConfig
 578:   baseConfig.id = id
 579:   baseConfig.name = name
 580:   baseConfig.year = Math.floor(year)
 581:   baseConfig.branding = {
 582:     tournamentLogoKey: `config/tournaments/${id}/logos/tournament.png`,
 583:     orgLogoKey: `config/tournaments/${id}/logos/org.png`,
 584:     primaryColor: baseConfig.branding.primaryColor,
 585:   }
 586:   baseConfig.teams = []
 587:   baseConfig.createdAt = now
 588:   baseConfig.updatedAt = now
 589:   await writeJsonToS3(getConfigKey(id, 'draft'), baseConfig)
 590:   const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
 591:   const nextList = list.filter((entry) => entry.id !== id)
 592:   nextList.push({ id, name, year: Math.floor(year), published: false })
 593:   await writeJsonToS3(CONFIG_LIST_KEY, nextList, { cacheControl: 'public, max-age=60' })
 594:   return c.json(baseConfig, 201)
 595: })
 596: app.put('/admin/tournaments/:id', async (c) => {
 597:   const id = c.req.param('id')
 598:   const body = await getJsonBody(c)
 599:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
 600:   const now = nowIso()
 601:   const config = body as TournamentConfig
 602:   if (!config.name || !config.year) {
 603:     return badRequest(c, 'name and year are required')
 604:   }
 605:   const existingConfig =
 606:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))) ??
 607:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
 608:     FALLBACK_CONFIGS[id] ??
 609:     null
 610:   const existingTeamIds = new Set(existingConfig?.teams?.map((team) => team.id) ?? [])
 611:   for (const team of config.teams ?? []) {
 612:     if (!isSafeId(team.id)) {
 613:       if (!existingTeamIds.has(team.id)) {
 614:         return badRequest(
 615:           c,
 616:           `Team id "${team.id}" must be 3-64 lowercase alphanumeric characters or hyphens`
 617:         )
 618:       }
 619:     }
 620:   }
 621:   config.id = id
 622:   config.updatedAt = now
 623:   config.createdAt = config.createdAt ?? now
 624:   await writeJsonToS3(getConfigKey(id, 'draft'), config)
 625:   return c.json(config)
 626: })
 627: app.post('/admin/tournaments/:id/logos-zip', async (c) => {
 628:   const id = c.req.param('id')
 629:   const draft =
 630:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))) ??
 631:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
 632:     FALLBACK_CONFIGS[id]
 633:   if (!draft) {
 634:     return c.json({ error: 'Tournament not found' }, 404)
 635:   }
 636:   const arrayBuffer = await c.req.arrayBuffer()
 637:   if (arrayBuffer.byteLength === 0) {
 638:     return badRequest(c, 'Empty request body')
 639:   }
 640:   let zip: JSZip
 641:   try {
 642:     zip = await JSZip.loadAsync(arrayBuffer)
 643:   } catch {
 644:     return badRequest(c, 'Invalid ZIP file')
 645:   }
 646:   const teamIds = new Set(draft.teams.map((t) => t.id))
 647:   const results: {
 648:     uploaded: string[]
 649:     skipped: Array<{ filename: string; reason: string }>
 650:     missingLogos: string[]
 651:   } = {
 652:     uploaded: [],
 653:     skipped: [],
 654:     missingLogos: [],
 655:   }
 656:   const uploadPromises: Promise<void>[] = []
 657:   zip.forEach((relativePath, file) => {
 658:     if (file.dir || relativePath.startsWith('__MACOSX') || relativePath.startsWith('.')) {
 659:       return
 660:     }
 661:     const filename = relativePath.split('/').pop() ?? relativePath
 662:     if (!filename.toLowerCase().endsWith('.png')) {
 663:       results.skipped.push({ filename, reason: 'Not a PNG file' })
 664:       return
 665:     }
 666:     const teamId = filename.slice(0, -4)
 667:     if (!teamIds.has(teamId)) {
 668:       results.skipped.push({ filename, reason: `No team with ID "${teamId}" in config` })
 669:       return
 670:     }
 671:     uploadPromises.push(
 672:       (async () => {
 673:         const data = await file.async('nodebuffer')
 674:         const key = `config/tournaments/${id}/teams/${teamId}.png`
 675:         await s3.send(
 676:           new PutObjectCommand({
 677:             Bucket: Resource.Media.name,
 678:             Key: key,
 679:             Body: data,
 680:             ContentType: 'image/png',
 681:           })
 682:         )
 683:         results.uploaded.push(teamId)
 684:       })()
 685:     )
 686:   })
 687:   await Promise.all(uploadPromises)
 688:   const uploadedSet = new Set(results.uploaded)
 689:   for (const team of draft.teams) {
 690:     if (!uploadedSet.has(team.id)) {
 691:       try {
 692:         await s3.send(
 693:           new HeadObjectCommand({
 694:             Bucket: Resource.Media.name,
 695:             Key: `config/tournaments/${id}/teams/${team.id}.png`,
 696:           })
 697:         )
 698:       } catch {
 699:         results.missingLogos.push(team.id)
 700:       }
 701:     }
 702:   }
 703:   return c.json(results)
 704: })
 705: app.post('/admin/tournaments/:id/assets/presign', async (c) => {
 706:   const id = c.req.param('id')
 707:   const body = await getJsonBody(c)
 708:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
 709:   const kind = normalizeString(body.kind)
 710:   const contentType = normalizeString(body.contentType)
 711:   const teamId = normalizeString(body.teamId)
 712:   const templateId = normalizeString(body.templateId)
 713:   if (!kind) return badRequest(c, 'kind is required')
 714:   if (!contentType) return badRequest(c, 'contentType is required')
 715:   if (kind === 'templateOverlay' && contentType !== 'image/png') {
 716:     return badRequest(c, 'templateOverlay must be image/png')
 717:   }
 718:   const ext = getExtension(contentType)
 719:   if (!ext) return badRequest(c, 'Unsupported contentType')
 720:   let key: string | null = null
 721:   if (kind === 'tournamentLogo') {
 722:     key = `config/tournaments/${id}/logos/tournament.${ext}`
 723:   } else if (kind === 'orgLogo') {
 724:     key = `config/tournaments/${id}/logos/org.${ext}`
 725:   } else if (kind === 'teamLogo') {
 726:     if (!teamId) return badRequest(c, 'teamId is required')
 727:     key = `config/tournaments/${id}/teams/${teamId}.${ext}`
 728:   } else if (kind === 'templateOverlay') {
 729:     if (!templateId) return badRequest(c, 'templateId is required')
 730:     if (!isSafeId(templateId)) return badRequest(c, 'templateId is invalid')
 731:     const uploadId = randomUUID().slice(0, 8)
 732:     key = `config/tournaments/${id}/overlays/${templateId}/${uploadId}.${ext}`
 733:   }
 734:   if (!key) return badRequest(c, 'kind is invalid')
 735:   const { url, fields } = await createPresignedPost(s3, {
 736:     Bucket: Resource.Media.name,
 737:     Key: key,
 738:     Fields: {
 739:       'Content-Type': contentType,
 740:     },
 741:     Conditions: [
 742:       ['content-length-range', 1, MAX_UPLOAD_BYTES],
 743:       ['eq', '$Content-Type', contentType],
 744:     ],
 745:     Expires: 900,
 746:   })
 747:   const publicUrl = getPublicPath(key)
 748:   const response: Record<string, unknown> = {
 749:     uploadUrl: url,
 750:     key,
 751:     method: 'POST',
 752:     fields,
 753:   }
 754:   if (publicUrl) response.publicUrl = publicUrl
 755:   return c.json(response)
 756: })
 757: app.post('/admin/tournaments/:id/publish', async (c) => {
 758:   const id = c.req.param('id')
 759:   const draftKey = getConfigKey(id, 'draft')
 760:   const publishedKey = getConfigKey(id, 'published')
 761:   const draft = await readJsonFromS3<TournamentConfig>(draftKey)
 762:   if (!draft) {
 763:     return c.json({ error: 'Draft config not found' }, 404)
 764:   }
 765:   await writeJsonToS3(publishedKey, draft, { cacheControl: 'public, max-age=60' })
 766:   const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
 767:   const nextList = list.map((entry) =>
 768:     entry.id === id ? { ...entry, published: true } : entry
 769:   )
 770:   await writeJsonToS3(CONFIG_LIST_KEY, nextList, { cacheControl: 'public, max-age=60' })
 771:   return c.json({ success: true })
 772: })
 773: app.get('/admin/tournaments/:id/bundle', async (c) => {
 774:   const id = c.req.param('id')
 775:   const config =
 776:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'draft'))) ??
 777:     (await readJsonFromS3<TournamentConfig>(getConfigKey(id, 'published'))) ??
 778:     FALLBACK_CONFIGS[id]
 779:   if (!config) {
 780:     return c.json({ error: 'Tournament not found' }, 404)
 781:   }
 782:   const zip = new JSZip()
 783:   zip.file('config.json', JSON.stringify(config, null, 2))
 784:   const addAsset = async (key: string, zipPath: string) => {
 785:     try {
 786:       const result = await s3.send(
 787:         new GetObjectCommand({
 788:           Bucket: Resource.Media.name,
 789:           Key: key,
 790:         })
 791:       )
 792:       if (result.Body) {
 793:         const data = await result.Body.transformToByteArray()
 794:         zip.file(zipPath, data)
 795:         return true
 796:       }
 797:     } catch {
 798:     }
 799:     return false
 800:   }
 801:   await addAsset(config.branding.tournamentLogoKey, 'tournament-logo.png')
 802:   if (config.branding.orgLogoKey) {
 803:     await addAsset(config.branding.orgLogoKey, 'org-logo.png')
 804:   }
 805:   const teamPromises = config.teams.map((team) =>
 806:     addAsset(team.logoKey, `teams/${team.id}.png`)
 807:   )
 808:   await Promise.all(teamPromises)
 809:   const zipBuffer = await zip.generateAsync({ type: 'nodebuffer' })
 810:   return new Response(zipBuffer, {
 811:     headers: {
 812:       'Content-Type': 'application/zip',
 813:       'Content-Disposition': `attachment; filename="${id}-bundle.zip"`,
 814:     },
 815:   })
 816: })
 817: app.post('/admin/tournaments/import-bundle', async (c) => {
 818:   const arrayBuffer = await c.req.arrayBuffer()
 819:   if (arrayBuffer.byteLength === 0) {
 820:     return badRequest(c, 'Empty request body')
 821:   }
 822:   let zip: JSZip
 823:   try {
 824:     zip = await JSZip.loadAsync(arrayBuffer)
 825:   } catch {
 826:     return badRequest(c, 'Invalid ZIP file')
 827:   }
 828:   const configFile = zip.file('config.json')
 829:   if (!configFile) {
 830:     return badRequest(c, 'ZIP must contain config.json at root level')
 831:   }
 832:   let config: TournamentConfig
 833:   try {
 834:     const configText = await configFile.async('text')
 835:     config = JSON.parse(configText) as TournamentConfig
 836:   } catch {
 837:     return badRequest(c, 'config.json is not valid JSON')
 838:   }
 839:   if (!config.id || typeof config.id !== 'string') {
 840:     return badRequest(c, 'config.json must have a valid id')
 841:   }
 842:   if (!isSafeId(config.id)) {
 843:     return badRequest(c, 'config.id must be 3-64 lowercase alphanumeric characters or hyphens')
 844:   }
 845:   if (!config.name || typeof config.name !== 'string') {
 846:     return badRequest(c, 'config.json must have a valid name')
 847:   }
 848:   if (!config.year || typeof config.year !== 'number') {
 849:     return badRequest(c, 'config.json must have a valid year')
 850:   }
 851:   for (const team of config.teams ?? []) {
 852:     if (!isSafeId(team.id)) {
 853:       return badRequest(c, `Team id "${team.id}" must be 3-64 lowercase alphanumeric characters or hyphens`)
 854:     }
 855:   }
 856:   const id = config.id
 857:   const now = nowIso()
 858:   config.branding = config.branding ?? { tournamentLogoKey: '' }
 859:   config.branding.tournamentLogoKey = `config/tournaments/${id}/logos/tournament.png`
 860:   if (config.branding.orgLogoKey) {
 861:     config.branding.orgLogoKey = `config/tournaments/${id}/logos/org.png`
 862:   }
 863:   // Update team logo keys to match tournament structure
 864:   config.teams = (config.teams ?? []).map((team) => ({
 865:     ...team,
 866:     logoKey: `config/tournaments/${id}/teams/${team.id}.png`,
 867:   }))
 868:   config.updatedAt = now
 869:   config.createdAt = config.createdAt ?? now
 870:   const results: {
 871:     configSaved: boolean
 872:     assetsUploaded: string[]
 873:     assetsSkipped: string[]
 874:   } = {
 875:     configSaved: false,
 876:     assetsUploaded: [],
 877:     assetsSkipped: [],
 878:   }
 879:   // Save config
 880:   await writeJsonToS3(getConfigKey(id, 'draft'), config)
 881:   results.configSaved = true
 882:   const tournamentLogo = zip.file('tournament-logo.png')
 883:   if (tournamentLogo) {
 884:     const data = await tournamentLogo.async('nodebuffer')
 885:     await s3.send(
 886:       new PutObjectCommand({
 887:         Bucket: Resource.Media.name,
 888:         Key: config.branding.tournamentLogoKey,
 889:         Body: data,
 890:         ContentType: 'image/png',
 891:       })
 892:     )
 893:     results.assetsUploaded.push('tournament-logo.png')
 894:   } else {
 895:     results.assetsSkipped.push('tournament-logo.png (not found in ZIP)')
 896:   }
 897:   const orgLogo = zip.file('org-logo.png')
 898:   if (orgLogo) {
 899:     const data = await orgLogo.async('nodebuffer')
 900:     await s3.send(
 901:       new PutObjectCommand({
 902:         Bucket: Resource.Media.name,
 903:         Key: `config/tournaments/${id}/logos/org.png`,
 904:         Body: data,
 905:         ContentType: 'image/png',
 906:       })
 907:     )
 908:     config.branding.orgLogoKey = `config/tournaments/${id}/logos/org.png`
 909:     results.assetsUploaded.push('org-logo.png')
 910:   }
 911:   const teamsFolder = zip.folder('teams')
 912:   if (teamsFolder) {
 913:     const teamPromises: Promise<void>[] = []
 914:     teamsFolder.forEach((relativePath, file) => {
 915:       if (file.dir || !relativePath.toLowerCase().endsWith('.png')) return
 916:       const filename = relativePath.split('/').pop() ?? relativePath
 917:       if (!filename.toLowerCase().endsWith('.png')) return
 918:       const teamId = filename.slice(0, -4)
 919:       if (!isSafeId(teamId)) {
 920:         results.assetsSkipped.push(`teams/${filename} (invalid team id)`)
 921:         return
 922:       }
 923:       teamPromises.push(
 924:         (async () => {
 925:           const data = await file.async('nodebuffer')
 926:           await s3.send(
 927:             new PutObjectCommand({
 928:               Bucket: Resource.Media.name,
 929:               Key: `config/tournaments/${id}/teams/${teamId}.png`,
 930:               Body: data,
 931:               ContentType: 'image/png',
 932:             })
 933:           )
 934:           results.assetsUploaded.push(`teams/${teamId}.png`)
 935:         })()
 936:       )
 937:     })
 938:     await Promise.all(teamPromises)
 939:   }
 940:   const list = (await readJsonFromS3<TournamentListEntry[]>(CONFIG_LIST_KEY)) ?? FALLBACK_TOURNAMENTS
 941:   const existing = list.find((entry) => entry.id === id)
 942:   if (!existing) {
 943:     list.push({ id, name: config.name, year: config.year, published: false })
 944:     await writeJsonToS3(CONFIG_LIST_KEY, list, { cacheControl: 'public, max-age=60' })
 945:   }
 946:   await writeJsonToS3(getConfigKey(id, 'draft'), config)
 947:   return c.json({ tournament: config, results })
 948: })
 949: app.post('/uploads/presign', async (c) => {
 950:   const body = await getJsonBody(c)
 951:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
 952:   const { cardId, contentType, contentLength, kind } = body as PresignRequest
 953:   if (typeof cardId !== 'string' || cardId.trim() === '') {
 954:     return badRequest(c, 'cardId is required')
 955:   }
 956:   if (typeof contentType !== 'string') {
 957:     return badRequest(c, 'contentType is required')
 958:   }
 959:   if (kind !== 'original' && kind !== 'crop' && kind !== 'render') {
 960:     return badRequest(c, 'kind is invalid')
 961:   }
 962:   const existingCard = await ddb.send(
 963:     new GetCommand({
 964:       TableName: Resource.Cards.name,
 965:       Key: { id: cardId },
 966:     })
 967:   )
 968:   if (!existingCard.Item) {
 969:     return c.json({ error: 'Card not found' }, 404)
 970:   }
 971:   const editToken = normalizeString(c.req.header(EDIT_TOKEN_HEADER))
 972:   if (!editToken) {
 973:     return c.json({ error: 'Edit token is required' }, 401)
 974:   }
 975:   const card = existingCard.Item as Card
 976:   if (!card.editToken || card.editToken !== editToken) {
 977:     return c.json({ error: 'Invalid edit token' }, 403)
 978:   }
 979:   if (card.status !== 'draft') {
 980:     return c.json({ error: 'Card is no longer editable' }, 409)
 981:   }
 982:   const length = typeof contentLength === 'number' ? contentLength : Number(contentLength)
 983:   if (!Number.isFinite(length) || length <= 0) {
 984:     return badRequest(c, 'contentLength must be a positive number')
 985:   }
 986:   if (length > MAX_UPLOAD_BYTES) {
 987:     return badRequest(c, 'File is too large')
 988:   }
 989:   const allowedTypes = kind === 'render' ? ALLOWED_RENDER_TYPES : ALLOWED_UPLOAD_TYPES
 990:   if (!allowedTypes.has(contentType)) {
 991:     return badRequest(c, 'contentType is not allowed')
 992:   }
 993:   const key = getUploadKey(cardId, kind, contentType)
 994:   if (!key) {
 995:     return badRequest(c, 'Unsupported contentType for this upload kind')
 996:   }
 997:   const { url, fields } = await createPresignedPost(s3, {
 998:     Bucket: Resource.Media.name,
 999:     Key: key,
1000:     Fields: {
1001:       'Content-Type': contentType,
1002:     },
1003:     Conditions: [
1004:       ['content-length-range', 1, MAX_UPLOAD_BYTES],
1005:       ['eq', '$Content-Type', contentType],
1006:     ],
1007:     Expires: 900,
1008:   })
1009:   const publicUrl = kind === 'render' ? getPublicPath(key) : null
1010:   const response: Record<string, unknown> = {
1011:     uploadUrl: url,
1012:     key,
1013:     method: 'POST',
1014:     fields,
1015:   }
1016:   if (publicUrl) response.publicUrl = publicUrl
1017:   return c.json(response)
1018: })
1019: app.post('/cards', async (c) => {
1020:   const body = await getJsonBody(c)
1021:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
1022:   const now = nowIso()
1023:   const id = randomUUID()
1024:   const editToken = randomUUID()
1025:   const input = pickCardInput(body)
1026:   const { cardType, tournamentId, ...rest } = input
1027:   if (!cardType || !isCardType(cardType)) {
1028:     return badRequest(c, 'cardType is required')
1029:   }
1030:   if (!tournamentId) {
1031:     return badRequest(c, 'tournamentId is required')
1032:   }
1033:   const fieldError = validateCardFields(input)
1034:   if (fieldError) {
1035:     return badRequest(c, fieldError)
1036:   }
1037:   const record: Card = {
1038:     id,
1039:     editToken,
1040:     tournamentId,
1041:     cardType,
1042:     status: 'draft',
1043:     createdAt: now,
1044:     updatedAt: now,
1045:     statusCreatedAt: buildStatusCreatedAt('draft', now),
1046:     ...rest,
1047:   }
1048:   const createPhotoKeyError = validatePhotoKeys(id, record.photo)
1049:   if (createPhotoKeyError) {
1050:     return badRequest(c, createPhotoKeyError)
1051:   }
1052:   await ddb.send(
1053:     new PutCommand({
1054:       TableName: Resource.Cards.name,
1055:       Item: record,
1056:     })
1057:   )
1058:   return c.json(record, 201)
1059: })
1060: app.get('/cards', async (c) => {
1061:   const statusParam = c.req.query('status')
1062:   if (!isCardStatus(statusParam)) {
1063:     return badRequest(c, 'status query param is required')
1064:   }
1065:   if (statusParam === 'draft') {
1066:     return c.json({ error: 'Draft cards require admin access' }, 403)
1067:   }
1068:   const tournamentId = c.req.query('tournamentId')
1069:   const limitParam = c.req.query('limit')
1070:   const limit = Math.min(100, Math.max(1, limitParam ? Number(limitParam) : 50))
1071:   if (tournamentId) {
1072:     const result = await ddb.send(
1073:       new QueryCommand({
1074:         TableName: Resource.Cards.name,
1075:         IndexName: 'byTournamentStatus',
1076:         KeyConditionExpression:
1077:           '#tournamentId = :tournamentId AND begins_with(#statusCreatedAt, :statusPrefix)',
1078:         ExpressionAttributeNames: {
1079:           '#tournamentId': 'tournamentId',
1080:           '#statusCreatedAt': 'statusCreatedAt',
1081:         },
1082:         ExpressionAttributeValues: {
1083:           ':tournamentId': tournamentId,
1084:           ':statusPrefix': `${statusParam}#`,
1085:         },
1086:         ScanIndexForward: false,
1087:         Limit: limit,
1088:       })
1089:     )
1090:     const items = (result.Items ?? []) as Card[]
1091:     return c.json(items.map(toPublicCard))
1092:   }
1093:   const result = await ddb.send(
1094:     new QueryCommand({
1095:       TableName: Resource.Cards.name,
1096:       IndexName: 'byStatus',
1097:       KeyConditionExpression: '#status = :status',
1098:       ExpressionAttributeNames: {
1099:         '#status': 'status',
1100:       },
1101:       ExpressionAttributeValues: {
1102:         ':status': statusParam,
1103:       },
1104:       ScanIndexForward: false,
1105:       Limit: limit,
1106:     })
1107:   )
1108:   const items = (result.Items ?? []) as Card[]
1109:   return c.json(items.map(toPublicCard))
1110: })
1111: app.get('/cards/:id', async (c) => {
1112:   const id = c.req.param('id')
1113:   const result = await ddb.send(
1114:     new GetCommand({
1115:       TableName: Resource.Cards.name,
1116:       Key: { id },
1117:     })
1118:   )
1119:   if (!result.Item) {
1120:     return c.json({ error: 'Card not found' }, 404)
1121:   }
1122:   return c.json(toPublicCard(result.Item as Card))
1123: })
1124: app.patch('/cards/:id', async (c) => {
1125:   const id = c.req.param('id')
1126:   const body = await getJsonBody(c)
1127:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
1128:   const editToken = normalizeString(c.req.header(EDIT_TOKEN_HEADER))
1129:   if (!editToken) {
1130:     return c.json({ error: 'Edit token is required' }, 401)
1131:   }
1132:   const now = nowIso()
1133:   if ('cardType' in body || 'tournamentId' in body || 'type' in body) {
1134:     return badRequest(c, 'cardType and tournamentId cannot be changed')
1135:   }
1136:   const draft: UpdateDraft = { set: {}, remove: [] }
1137:   let error =
1138:     applyStringUpdate(draft, body.teamId, 'teamId', MAX_TEAM_LENGTH, 'teamId') ||
1139:     applyStringUpdate(draft, body.teamName, 'teamName', MAX_TEAM_LENGTH, 'teamName') ||
1140:     applyStringUpdate(draft, body.position, 'position', MAX_POSITION_LENGTH, 'position') ||
1141:     applyStringUpdate(draft, body.templateId, 'templateId', MAX_TEMPLATE_LENGTH, 'templateId') ||
1142:     applyStringUpdate(draft, body.firstName, 'firstName', MAX_NAME_LENGTH, 'firstName') ||
1143:     applyStringUpdate(draft, body.lastName, 'lastName', MAX_NAME_LENGTH, 'lastName') ||
1144:     applyStringUpdate(draft, body.photographer, 'photographer', MAX_PHOTOGRAPHER_LENGTH, 'photographer') ||
1145:     applyStringUpdate(draft, body.title, 'title', MAX_TITLE_LENGTH, 'title') ||
1146:     applyStringUpdate(draft, body.caption, 'caption', MAX_CAPTION_LENGTH, 'caption')
1147:   if (!error && body.jerseyNumber !== undefined) {
1148:     if (body.jerseyNumber === null) {
1149:       pushRemove(draft, 'jerseyNumber')
1150:     } else if (typeof body.jerseyNumber === 'string') {
1151:       const trimmed = body.jerseyNumber.trim()
1152:       if (!trimmed) {
1153:         pushRemove(draft, 'jerseyNumber')
1154:       } else if (!JERSEY_PATTERN.test(trimmed)) {
1155:         error = 'jerseyNumber must be 1-2 digits'
1156:       } else {
1157:         pushSet(draft, 'jerseyNumber', trimmed)
1158:       }
1159:     } else {
1160:       error = 'jerseyNumber must be a string'
1161:     }
1162:   }
1163:   if (!error && body.photo !== undefined) {
1164:     if (body.photo === null) {
1165:       pushRemove(draft, 'photo')
1166:     } else if (isRecord(body.photo)) {
1167:       const photoUpdate: Card['photo'] = {}
1168:       if (body.photo.originalKey !== undefined && body.photo.originalKey !== null) {
1169:         if (typeof body.photo.originalKey !== 'string') {
1170:           error = 'photo.originalKey must be a string'
1171:         } else {
1172:           const trimmed = body.photo.originalKey.trim()
1173:           if (trimmed) {
1174:             const lengthError = ensureMaxLength(trimmed, 1024, 'photo.originalKey')
1175:             if (lengthError) {
1176:               error = lengthError
1177:             } else {
1178:               photoUpdate.originalKey = trimmed
1179:             }
1180:           }
1181:         }
1182:       }
1183:       if (!error && body.photo.cropKey !== undefined && body.photo.cropKey !== null) {
1184:         if (typeof body.photo.cropKey !== 'string') {
1185:           error = 'photo.cropKey must be a string'
1186:         } else {
1187:           const trimmed = body.photo.cropKey.trim()
1188:           if (trimmed) {
1189:             const lengthError = ensureMaxLength(trimmed, 1024, 'photo.cropKey')
1190:             if (lengthError) {
1191:               error = lengthError
1192:             } else {
1193:               photoUpdate.cropKey = trimmed
1194:             }
1195:           }
1196:         }
1197:       }
1198:       if (!error && body.photo.width !== undefined && body.photo.width !== null) {
1199:         const width = toNumber(body.photo.width)
1200:         if (width === undefined) {
1201:           error = 'photo.width must be a number'
1202:         } else {
1203:           photoUpdate.width = width
1204:         }
1205:       }
1206:       if (!error && body.photo.height !== undefined && body.photo.height !== null) {
1207:         const height = toNumber(body.photo.height)
1208:         if (height === undefined) {
1209:           error = 'photo.height must be a number'
1210:         } else {
1211:           photoUpdate.height = height
1212:         }
1213:       }
1214:       if (!error && body.photo.crop !== undefined && body.photo.crop !== null) {
1215:         const crop = pickCrop(body.photo.crop)
1216:         if (!crop) {
1217:           error = 'photo.crop is invalid'
1218:         } else {
1219:           photoUpdate.crop = crop
1220:         }
1221:       }
1222:       if (!error) {
1223:         if (Object.keys(photoUpdate).length === 0) {
1224:           error = 'photo must include at least one field'
1225:         } else {
1226:           const photoKeyError = validatePhotoKeys(id, photoUpdate)
1227:           if (photoKeyError) {
1228:             error = photoKeyError
1229:           } else {
1230:             for (const [key, value] of Object.entries(photoUpdate)) {
1231:               pushSet(draft, `photo.${key}`, value)
1232:             }
1233:           }
1234:         }
1235:       }
1236:     } else {
1237:       error = 'photo must be an object'
1238:     }
1239:   }
1240:   if (error) {
1241:     return badRequest(c, error)
1242:   }
1243:   pushSet(draft, 'updatedAt', now)
1244:   const entries = Object.entries(draft.set)
1245:   const sets: string[] = []
1246:   const removes: string[] = []
1247:   const names: Record<string, string> = {}
1248:   const nameMap = new Map<string, string>()
1249:   const values: Record<string, unknown> = {}
1250:   let valueIndex = 0
1251:   let nameIndex = 0
1252:   const nameFor = (segment: string) => {
1253:     const existing = nameMap.get(segment)
1254:     if (existing) return existing
1255:     const key = `#n${nameIndex++}`
1256:     nameMap.set(segment, key)
1257:     names[key] = segment
1258:     return key
1259:   }
1260:   const pathToExpression = (path: string) =>
1261:     path
1262:       .split('.')
1263:       .map((segment) => nameFor(segment))
1264:       .join('.')
1265:   for (const [path, value] of entries) {
1266:     const placeholder = `:v${valueIndex++}`
1267:     values[placeholder] = value
1268:     sets.push(`${pathToExpression(path)} = ${placeholder}`)
1269:   }
1270:   for (const path of draft.remove) {
1271:     removes.push(pathToExpression(path))
1272:   }
1273:   values[':draft'] = 'draft'
1274:   values[':editToken'] = editToken
1275:   const updateExpressions = []
1276:   if (sets.length > 0) updateExpressions.push(`SET ${sets.join(', ')}`)
1277:   if (removes.length > 0) updateExpressions.push(`REMOVE ${removes.join(', ')}`)
1278:   try {
1279:     const result = await ddb.send(
1280:       new UpdateCommand({
1281:         TableName: Resource.Cards.name,
1282:         Key: { id },
1283:         UpdateExpression: updateExpressions.join(' '),
1284:         ConditionExpression: 'attribute_exists(#id) AND #status = :draft AND #editToken = :editToken',
1285:         ExpressionAttributeNames: {
1286:           ...names,
1287:           '#id': 'id',
1288:           '#status': 'status',
1289:           '#editToken': 'editToken',
1290:         },
1291:         ExpressionAttributeValues: values,
1292:         ReturnValues: 'ALL_NEW',
1293:       })
1294:     )
1295:     if (!result.Attributes) {
1296:       return c.json({ error: 'Card not found' }, 404)
1297:     }
1298:     return c.json(result.Attributes)
1299:   } catch (err) {
1300:     if (err instanceof ConditionalCheckFailedException || (isRecord(err) && err.name === 'ConditionalCheckFailedException')) {
1301:       const latest = await ddb.send(
1302:         new GetCommand({
1303:           TableName: Resource.Cards.name,
1304:           Key: { id },
1305:         })
1306:       )
1307:       if (!latest.Item) {
1308:         return c.json({ error: 'Card not found' }, 404)
1309:       }
1310:       const current = latest.Item as Card
1311:       if (!current.editToken || current.editToken !== editToken) {
1312:         return c.json({ error: 'Invalid edit token' }, 403)
1313:       }
1314:       return c.json({ error: 'Card is no longer editable' }, 409)
1315:     }
1316:     throw err
1317:   }
1318: })
1319: app.post('/cards/:id/submit', async (c) => {
1320:   const id = c.req.param('id')
1321:   const existing = await ddb.send(
1322:     new GetCommand({
1323:       TableName: Resource.Cards.name,
1324:       Key: { id },
1325:     })
1326:   )
1327:   if (!existing.Item) {
1328:     return c.json({ error: 'Card not found' }, 404)
1329:   }
1330:   const card = existing.Item as Card
1331:   const editToken = normalizeString(c.req.header(EDIT_TOKEN_HEADER))
1332:   if (!editToken) {
1333:     return c.json({ error: 'Edit token is required' }, 401)
1334:   }
1335:   if (!card.editToken || card.editToken !== editToken) {
1336:     return c.json({ error: 'Invalid edit token' }, 403)
1337:   }
1338:   if (card.status !== 'draft') {
1339:     return c.json(card)
1340:   }
1341:   const body = await getJsonBody(c)
1342:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
1343:   let renderKey: string | undefined
1344:   if (body.renderKey !== undefined && body.renderKey !== null) {
1345:     if (typeof body.renderKey !== 'string' || body.renderKey.trim() === '') {
1346:       return badRequest(c, 'renderKey must be a non-empty string')
1347:     }
1348:     renderKey = body.renderKey.trim()
1349:   }
1350:   let renderMeta: RenderMeta | undefined
1351:   if (body.renderMeta !== undefined) {
1352:     if (!renderKey) return badRequest(c, 'renderMeta requires renderKey')
1353:     const parsed = parseRenderMeta(body.renderMeta, renderKey)
1354:     if (typeof parsed === 'string') return badRequest(c, parsed)
1355:     renderMeta = parsed
1356:   }
1357:   const submitValidationError = getSubmitValidationError(card)
1358:   if (submitValidationError) {
1359:     return badRequest(c, submitValidationError)
1360:   }
1361:   if (renderKey) {
1362:     const renderKeyPattern = new RegExp(`^renders/${id}/[a-f0-9-]+\\.png$`)
1363:     if (!renderKeyPattern.test(renderKey)) {
1364:       return badRequest(c, 'Invalid renderKey format')
1365:     }
1366:     try {
1367:       await s3.send(
1368:         new HeadObjectCommand({
1369:           Bucket: Resource.Media.name,
1370:           Key: renderKey,
1371:         })
1372:       )
1373:     } catch {
1374:       return badRequest(c, 'renderKey not found in storage')
1375:     }
1376:   }
1377:   const now = nowIso()
1378:   const statusCreatedAt = buildStatusCreatedAt('submitted', now)
1379:   try {
1380:     const setExpressions = ['#status = :status', '#updatedAt = :updatedAt', '#statusCreatedAt = :statusCreatedAt']
1381:     const expressionAttributeNames: Record<string, string> = {
1382:       '#status': 'status',
1383:       '#updatedAt': 'updatedAt',
1384:       '#statusCreatedAt': 'statusCreatedAt',
1385:     }
1386:     const expressionAttributeValues: Record<string, unknown> = {
1387:       ':status': 'submitted',
1388:       ':draft': 'draft',
1389:       ':updatedAt': now,
1390:       ':statusCreatedAt': statusCreatedAt,
1391:     }
1392:     if (renderKey) {
1393:       setExpressions.push('#renderKey = :renderKey')
1394:       expressionAttributeNames['#renderKey'] = 'renderKey'
1395:       expressionAttributeValues[':renderKey'] = renderKey
1396:     }
1397:     if (renderMeta) {
1398:       setExpressions.push('#renderMeta = :renderMeta')
1399:       expressionAttributeNames['#renderMeta'] = 'renderMeta'
1400:       expressionAttributeValues[':renderMeta'] = renderMeta
1401:     }
1402:     const result = await ddb.send(
1403:       new UpdateCommand({
1404:         TableName: Resource.Cards.name,
1405:         Key: { id },
1406:         UpdateExpression: `SET ${setExpressions.join(', ')}`,
1407:         ConditionExpression: '#status = :draft',
1408:         ExpressionAttributeNames: expressionAttributeNames,
1409:         ExpressionAttributeValues: expressionAttributeValues,
1410:         ReturnValues: 'ALL_NEW',
1411:       })
1412:     )
1413:     if (result.Attributes) {
1414:       return c.json(result.Attributes)
1415:     }
1416:     const next: Card = {
1417:       ...card,
1418:       renderKey: renderKey ?? card.renderKey,
1419:       renderMeta: renderMeta ?? card.renderMeta,
1420:       status: 'submitted',
1421:       updatedAt: now,
1422:       statusCreatedAt,
1423:     }
1424:     return c.json(next)
1425:   } catch (err) {
1426:     if (err instanceof ConditionalCheckFailedException || (isRecord(err) && err.name === 'ConditionalCheckFailedException')) {
1427:       const latest = await ddb.send(
1428:         new GetCommand({
1429:           TableName: Resource.Cards.name,
1430:           Key: { id },
1431:         })
1432:       )
1433:       if (latest.Item) {
1434:         return c.json(latest.Item)
1435:       }
1436:       return c.json({ error: 'Card not found' }, 404)
1437:     }
1438:     throw err
1439:   }
1440: })
1441: app.get('/admin/cards', async (c) => {
1442:   const statusParam = c.req.query('status')
1443:   if (!isCardStatus(statusParam)) {
1444:     return badRequest(c, 'status query param is required')
1445:   }
1446:   const tournamentId = c.req.query('tournamentId')
1447:   const limitParam = c.req.query('limit')
1448:   const limit = Math.min(100, Math.max(1, limitParam ? Number(limitParam) : 50))
1449:   if (tournamentId) {
1450:     const result = await ddb.send(
1451:       new QueryCommand({
1452:         TableName: Resource.Cards.name,
1453:         IndexName: 'byTournamentStatus',
1454:         KeyConditionExpression:
1455:           '#tournamentId = :tournamentId AND begins_with(#statusCreatedAt, :statusPrefix)',
1456:         ExpressionAttributeNames: {
1457:           '#tournamentId': 'tournamentId',
1458:           '#statusCreatedAt': 'statusCreatedAt',
1459:         },
1460:         ExpressionAttributeValues: {
1461:           ':tournamentId': tournamentId,
1462:           ':statusPrefix': `${statusParam}#`,
1463:         },
1464:         ScanIndexForward: false,
1465:         Limit: limit,
1466:       })
1467:     )
1468:     return c.json(result.Items ?? [])
1469:   }
1470:   const result = await ddb.send(
1471:     new QueryCommand({
1472:       TableName: Resource.Cards.name,
1473:       IndexName: 'byStatus',
1474:       KeyConditionExpression: '#status = :status',
1475:       ExpressionAttributeNames: {
1476:         '#status': 'status',
1477:       },
1478:       ExpressionAttributeValues: {
1479:         ':status': statusParam,
1480:       },
1481:       ScanIndexForward: false,
1482:       Limit: limit,
1483:     })
1484:   )
1485:   return c.json(result.Items ?? [])
1486: })
1487: app.patch('/admin/cards/:id', async (c) => {
1488:   const id = c.req.param('id')
1489:   const body = await getJsonBody(c)
1490:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
1491:   const keys = Object.keys(body)
1492:   if (keys.length === 0 || keys.some((key) => key !== 'templateId')) {
1493:     return badRequest(c, 'Only templateId can be updated')
1494:   }
1495:   const templateIdInput = body.templateId
1496:   let templateId: string | null = null
1497:   let removeTemplateId = false
1498:   if (templateIdInput === null) {
1499:     removeTemplateId = true
1500:   } else if (typeof templateIdInput === 'string') {
1501:     const trimmed = templateIdInput.trim()
1502:     if (!trimmed) {
1503:       removeTemplateId = true
1504:     } else {
1505:       const error = ensureMaxLength(trimmed, MAX_TEMPLATE_LENGTH, 'templateId')
1506:       if (error) return badRequest(c, error)
1507:       templateId = trimmed
1508:     }
1509:   } else {
1510:     return badRequest(c, 'templateId must be a string')
1511:   }
1512:   const now = nowIso()
1513:   const setExpressions = ['#updatedAt = :updatedAt']
1514:   const removeExpressions: string[] = []
1515:   const names: Record<string, string> = {
1516:     '#id': 'id',
1517:     '#updatedAt': 'updatedAt',
1518:     '#templateId': 'templateId',
1519:   }
1520:   const values: Record<string, unknown> = {
1521:     ':updatedAt': now,
1522:   }
1523:   if (templateId) {
1524:     setExpressions.push('#templateId = :templateId')
1525:     values[':templateId'] = templateId
1526:   } else if (removeTemplateId) {
1527:     removeExpressions.push('#templateId')
1528:   }
1529:   const updateExpression = `SET ${setExpressions.join(', ')}${
1530:     removeExpressions.length > 0 ? ` REMOVE ${removeExpressions.join(', ')}` : ''
1531:   }`
1532:   const result = await ddb.send(
1533:     new UpdateCommand({
1534:       TableName: Resource.Cards.name,
1535:       Key: { id },
1536:       UpdateExpression: updateExpression,
1537:       ConditionExpression: 'attribute_exists(#id)',
1538:       ExpressionAttributeNames: names,
1539:       ExpressionAttributeValues: values,
1540:       ReturnValues: 'ALL_NEW',
1541:     })
1542:   )
1543:   if (!result.Attributes) {
1544:     return c.json({ error: 'Card not found' }, 404)
1545:   }
1546:   return c.json(result.Attributes)
1547: })
1548: app.get('/admin/cards/:id/photo-url', async (c) => {
1549:   const id = c.req.param('id')
1550:   const existing = await ddb.send(
1551:     new GetCommand({
1552:       TableName: Resource.Cards.name,
1553:       Key: { id },
1554:     })
1555:   )
1556:   if (!existing.Item) {
1557:     return c.json({ error: 'Card not found' }, 404)
1558:   }
1559:   const card = existing.Item as Card
1560:   const originalKey = card.photo?.originalKey
1561:   if (!originalKey) {
1562:     return c.json({ error: 'Card has no original photo' }, 400)
1563:   }
1564:   const url = await getSignedUrl(
1565:     s3,
1566:     new GetObjectCommand({
1567:       Bucket: Resource.Media.name,
1568:       Key: originalKey,
1569:     }),
1570:     { expiresIn: 300 }
1571:   )
1572:   return c.json({ url })
1573: })
1574: app.post('/admin/cards/:id/renders/presign', async (c) => {
1575:   const id = c.req.param('id')
1576:   const body = await getJsonBody(c)
1577:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
1578:   const existing = await ddb.send(
1579:     new GetCommand({
1580:       TableName: Resource.Cards.name,
1581:       Key: { id },
1582:     })
1583:   )
1584:   if (!existing.Item) {
1585:     return c.json({ error: 'Card not found' }, 404)
1586:   }
1587:   const card = existing.Item as Card
1588:   if (card.status === 'draft') {
1589:     return badRequest(c, 'Draft cards cannot be rendered')
1590:   }
1591:   const contentType = normalizeString(body.contentType)
1592:   if (!contentType) return badRequest(c, 'contentType is required')
1593:   const length = typeof body.contentLength === 'number' ? body.contentLength : Number(body.contentLength)
1594:   if (!Number.isFinite(length) || length <= 0) {
1595:     return badRequest(c, 'contentLength must be a positive number')
1596:   }
1597:   if (length > MAX_UPLOAD_BYTES) {
1598:     return badRequest(c, 'File is too large')
1599:   }
1600:   if (!ALLOWED_RENDER_TYPES.has(contentType)) {
1601:     return badRequest(c, 'contentType is not allowed')
1602:   }
1603:   const key = getUploadKey(id, 'render', contentType)
1604:   if (!key) return badRequest(c, 'Unsupported contentType for render upload')
1605:   const { url, fields } = await createPresignedPost(s3, {
1606:     Bucket: Resource.Media.name,
1607:     Key: key,
1608:     Fields: {
1609:       'Content-Type': contentType,
1610:     },
1611:     Conditions: [
1612:       ['content-length-range', 1, MAX_UPLOAD_BYTES],
1613:       ['eq', '$Content-Type', contentType],
1614:     ],
1615:     Expires: 900,
1616:   })
1617:   return c.json({
1618:     uploadUrl: url,
1619:     key,
1620:     method: 'POST',
1621:     fields,
1622:   })
1623: })
1624: app.post('/admin/cards/:id/renders/commit', async (c) => {
1625:   const id = c.req.param('id')
1626:   const body = await getJsonBody(c)
1627:   if (!isRecord(body)) return badRequest(c, 'Invalid request body')
1628:   const renderKey = normalizeString(body.renderKey)
1629:   if (!renderKey) return badRequest(c, 'renderKey is required')
1630:   if (body.renderMeta === undefined) {
1631:     return badRequest(c, 'renderMeta is required')
1632:   }
1633:   const renderMeta = parseRenderMeta(body.renderMeta, renderKey)
1634:   if (typeof renderMeta === 'string') {
1635:     return badRequest(c, renderMeta)
1636:   }
1637:   const renderKeyPattern = new RegExp(`^renders/${id}/[a-f0-9-]+\\.png$`)
1638:   if (!renderKeyPattern.test(renderKey)) {
1639:     return badRequest(c, 'Invalid renderKey format')
1640:   }
1641:   const existing = await ddb.send(
1642:     new GetCommand({
1643:       TableName: Resource.Cards.name,
1644:       Key: { id },
1645:     })
1646:   )
1647:   if (!existing.Item) {
1648:     return c.json({ error: 'Card not found' }, 404)
1649:   }
1650:   const card = existing.Item as Card
1651:   if (card.status === 'draft') {
1652:     return badRequest(c, 'Draft cards cannot be rendered')
1653:   }
1654:   try {
1655:     await s3.send(
1656:       new HeadObjectCommand({
1657:         Bucket: Resource.Media.name,
1658:         Key: renderKey,
1659:       })
1660:     )
1661:   } catch {
1662:     return badRequest(c, 'renderKey not found in storage')
1663:   }
1664:   const now = nowIso()
1665:   const statusCreatedAt = buildStatusCreatedAt('rendered', now)
1666:   const result = await ddb.send(
1667:     new UpdateCommand({
1668:       TableName: Resource.Cards.name,
1669:       Key: { id },
1670:       UpdateExpression:
1671:         'SET #renderKey = :renderKey, #renderMeta = :renderMeta, #status = :status, #updatedAt = :updatedAt, #statusCreatedAt = :statusCreatedAt',
1672:       ExpressionAttributeNames: {
1673:         '#renderKey': 'renderKey',
1674:         '#renderMeta': 'renderMeta',
1675:         '#status': 'status',
1676:         '#updatedAt': 'updatedAt',
1677:         '#statusCreatedAt': 'statusCreatedAt',
1678:       },
1679:       ExpressionAttributeValues: {
1680:         ':renderKey': renderKey,
1681:         ':renderMeta': renderMeta,
1682:         ':status': 'rendered',
1683:         ':updatedAt': now,
1684:         ':statusCreatedAt': statusCreatedAt,
1685:       },
1686:       ReturnValues: 'ALL_NEW',
1687:     })
1688:   )
1689:   return c.json(result.Attributes ?? {
1690:     ...card,
1691:     renderKey,
1692:     renderMeta,
1693:     status: 'rendered',
1694:     updatedAt: now,
1695:     statusCreatedAt,
1696:   })
1697: })
1698: app.post('/admin/cards/:id/render', async (c) => {
1699:   const id = c.req.param('id')
1700:   const now = nowIso()
1701:   const existing = await ddb.send(
1702:     new GetCommand({
1703:       TableName: Resource.Cards.name,
1704:       Key: { id },
1705:     })
1706:   )
1707:   if (!existing.Item) {
1708:     return c.json({ error: 'Card not found' }, 404)
1709:   }
1710:   const card = existing.Item as Card
1711:   if (card.status !== 'submitted') {
1712:     return badRequest(c, 'Only submitted cards can be marked rendered')
1713:   }
1714:   const statusCreatedAt = buildStatusCreatedAt('rendered', now)
1715:   const result = await ddb.send(
1716:     new UpdateCommand({
1717:       TableName: Resource.Cards.name,
1718:       Key: { id },
1719:       UpdateExpression: 'SET #status = :status, #updatedAt = :updatedAt, #statusCreatedAt = :statusCreatedAt',
1720:       ExpressionAttributeNames: {
1721:         '#status': 'status',
1722:         '#updatedAt': 'updatedAt',
1723:         '#statusCreatedAt': 'statusCreatedAt',
1724:       },
1725:       ExpressionAttributeValues: {
1726:         ':status': 'rendered',
1727:         ':updatedAt': now,
1728:         ':statusCreatedAt': statusCreatedAt,
1729:       },
1730:       ReturnValues: 'ALL_NEW',
1731:     })
1732:   )
1733:   return c.json(result.Attributes ?? card)
1734: })
1735: app.get('/admin/cards/:id/download-url', async (c) => {
1736:   const id = c.req.param('id')
1737:   const existing = await ddb.send(
1738:     new GetCommand({
1739:       TableName: Resource.Cards.name,
1740:       Key: { id },
1741:     })
1742:   )
1743:   if (!existing.Item) {
1744:     return c.json({ error: 'Card not found' }, 404)
1745:   }
1746:   const card = existing.Item as Card
1747:   if (!card.renderKey) {
1748:     return c.json({ error: 'Card has no render' }, 400)
1749:   }
1750:   const url = await getSignedUrl(
1751:     s3,
1752:     new GetObjectCommand({
1753:       Bucket: Resource.Media.name,
1754:       Key: card.renderKey,
1755:       ResponseContentDisposition: `attachment; filename="${id}.png"`,
1756:     }),
1757:     { expiresIn: 300 }
1758:   )
1759:   return c.json({ url })
1760: })
1761: app.delete('/admin/cards/:id', async (c) => {
1762:   const id = c.req.param('id')
1763:   const existing = await ddb.send(
1764:     new GetCommand({
1765:       TableName: Resource.Cards.name,
1766:       Key: { id },
1767:     })
1768:   )
1769:   if (!existing.Item) {
1770:     return c.json({ error: 'Card not found' }, 404)
1771:   }
1772:   const card = existing.Item as Card
1773:   if (card.status !== 'draft') {
1774:     return badRequest(c, 'Only draft cards can be deleted')
1775:   }
1776:   await ddb.send(
1777:     new DeleteCommand({
1778:       TableName: Resource.Cards.name,
1779:       Key: { id },
1780:     })
1781:   )
1782:   return c.json({ success: true })
1783: })
1784: app.notFound((c) => c.json({ error: 'Not Found' }, 404))
1785: app.onError((err, c) => {
1786:   console.error('Server error:', err)
1787:   const message = err instanceof Error ? err.message : 'Internal Server Error'
1788:   return c.json({ error: message }, 500)
1789: })
1790: export default app
</file>

</files>
